'use strict';
const qtoolsGen = require('qtools');
const qtools = new qtoolsGen(module);
const jwt=require('jsonwebtoken');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {

	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'config',
				optional: false
			}
		]
	});

	qtools.validateProperties({
		subject: this.config || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'roleList',
				optional: false
			}
		]
	});

	this.routeList = [];

	//LOCAL VARIABLES ====================================

	//LOCAL FUNCTIONS ====================================

	//METHODS AND PROPERTIES ====================================

	this.shutdown = (message, callback) => {
		console.log(`shutting down ${__dirname}`);
		callback('', message);
	}

	this.getRole = (name, callback) => {
		const role = qtools.getByProperty(this.roleList, 'name', name);
		if (!role) {
			if (callback) {
				callback(`no such role as $(roleName) in configuration`);
			} else {
				throw `no such role as $(roleName) in configuration`;
			}
		} else {
			if (callback) {
				callback('', role);
			} else {
				return role;
			}
		}
	}

	this.addRoute = (route, role, method) => {
		this.routeList.push({
			route: route,
			role: role,
			method:method
		});
	}

	const getByPath = (path, method) => {
		for (var i = 0, len = this.routeList.length; i < len; i++) {
			var element = this.routeList[i];
			if (path.match(element.route)) {
				if (!element.method){
					return element;
				}
				
				if (element.method && element.method.toLowerCase()==method.toLowerCase()){
					return element;
				}
			}
		}
		return;
	}

	const badToken = (req) => {
		const routeItem = getByPath(req.path, req.method);
		
		if (!routeItem){
				return {
				code: '404',
				message: 'Not Found'
			}
		}
		
		if (req.token && req.token.jwt){
			try{
					var decoded = jwt.verify(req.token.jwt, this.config.system.secret);
					req.tokenJwtDecoded=decoded;
			}
			catch(e){
				return 'Invalid Token Format';
			}
		}
			
		if (routeItem.role == 'all') {
			req.publicRole=true;
			return false;
		} else {
		
			if (!req.tokenJwtDecoded){
				return "No Session Token Found"
			}

			if (decoded.expiration < Date.now()){
				return 'Session Expired';
			}
			
			if (!routeItem.role){
				return 'Internal Error - Path has no role';
			}
			
			if (!decoded.role){
				return 'Malformed token - no role included';
			}
			
			if (!routeItem.role.match(decoded.role)){
				return 'Invalid Role';
			}
			
			return false;
		}
	}

	this.checkPath = (req, res, next) => {
		const isBad=badToken(req);
		if (!isBad) {
			next();
		} else {
			if (typeof(isBad)=='object'){
				next(isBad);
			}
			else{
			next({
				code: '401',
				message: isBad
			});
			}
		}


	}
	
	this.getToken=(user)=>{
		const expTime=Date.now()+this.config.system.sessionExpireMinutes*60000;
		const claims={ role:user.role, expiration:expTime, userRefId:user.refId, _id:user._id };
		return {
			claims:claims,
			jwt:jwt.sign(claims, this.config.system.secret)
		}
	}
	
	this.updateToken=function(req){
	if (!req.tokenJwtDecoded && req.publicRole){
		return {
			public:true
		};
	}
		const expTime=Date.now()+this.config.system.sessionExpireMinutes*60000;
		const claims={ role:req.tokenJwtDecoded.role, expiration:expTime, userRefId:req.tokenJwtDecoded.userRefId, _id:req.tokenJwtDecoded._id };
		return {
			claims:claims,
			jwt:jwt.sign(claims, this.config.system.secret)
		}
	}

	//API ENDPOINTS ====================================

	//INITIALIZATION ====================================
	

	return this;
};

//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();

