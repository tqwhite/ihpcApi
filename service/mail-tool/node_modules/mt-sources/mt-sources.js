'use strict';
const qtoolsGen = require('qtools');
const qtools = new qtoolsGen(module);
const async = require('async');
const asynchronousPipe = require('asynchronous-pipe');
const later = require('later');

let multiIni = require('multi-ini');
multiIni = new multiIni.Class({
	filters: [
		value => {
			if (isNaN(+value)) {
				return value;
			} else {
				return +value;
			}
		}
	]
});

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'config',
				optional: false
			},
			{
				name: 'apiManager',
				optional: false
			},
			{
				name: 'initCallback',
				optional: true
			}
		]
	});

	qtools.validateProperties({
		subject: this.config.mtMessages || {},
		propList: [
			{
				name: 'autoEmailDirectoryPath',
				optional: false
			}
		]
	});

	//LOCAL VARIABLES ====================================

	const templateDirectoryPath = this.config.mtMessages.autoEmailDirectoryPath;

	//LOCAL FUNCTIONS ====================================

	const toDictionary = user => {
		return Object.keys(user).map(key => {
			let value = user[key];
			if (typeof user[key].toUTCString != 'undefined') {
				const dateVersion = qtools.getDateString('mm_dd_yyyy', user[key]);
				if (dateVersion && dateVersion.toString() != 'Invalid Date') {
					value = dateVersion;
				}
			}
			if (key == 'lastLogin') {
				value = qtools.getDateString('mm_dd_yyyy timeDetails', user[key]);
			}
			if (key == 'pwhash' || key == 'salt') {
				value = '#########';
			}
			return { pattern: key, replacement: value };
		});
	};

	const batchStartNotification = (templateDirectoryPath, next) => {
		qtools.logMilestone(`starting generate/queue autoEmail batch`);
		next('', templateDirectoryPath);
	};

	const checkTemplateDirectory = (templateDirectoryPath, next) => {
		const localCallback = (err, stats) => {
			if (stats && stats.isDirectory()) {
				next('', templateDirectoryPath);
			} else {
				next({
					code: 'mt-sources-1',
					errorText: `AutoMail Template Directory Path does not point to a directory (${templateDirectoryPath})`,
					err: stats
						? stats
						: `invalid directory path (${templateDirectoryPath})`
				});
			}
		};
		qtools.fs.stat(templateDirectoryPath, localCallback);
	};

	const getTemplateFileList = (templateDirectoryPath, next) => {
		const localCallback = (err, fileList = []) => {
			next(
				err,
				fileList.map(fileName => `${templateDirectoryPath}/${fileName}`)
			);
		};
		qtools.fs.readdir(templateDirectoryPath, localCallback);
	};

	const buildTemplateList = (filePathList, next) => {
		const buildParameterBundle = (filePath, next) => {
			const templateDetails = multiIni.read(filePath);
			const templateName = filePath.match(/^\/.*\/(.*?)\.ini$/)[1];
			const parameterBundle = {
				templateName: '/autoEmail/' + templateName,
				timing: templateDetails.templates.timing,
				inactiveFlag: templateDetails.templates.inactiveFlag
			};
			next('', parameterBundle);
		};
		async.map(filePathList, buildParameterBundle, (err, result) => {
			next(err, result);
		}); //I know, this doesn't need to be async but, everything else here is, so I don't want to break pattern.
	};

	const queueMessages = (parameterBundleList = [], asyncPipeNext) => {
		const taskList = parameterBundleList.map(parameterBundle => {
			return localNext => {
				const emailTasks = [];

				emailTasks.push((parameterBundle, next) => {
					const localCallback = (err, userList) => {
						if (err) {
							next(err);
							return;
						}
						qtools.logMilestone(
							`queuing email '${parameterBundle.templateName}' for ${userList.length} users`
						);
						const mailSendingPackage = {
							userList: userList,
							parameterBundle: parameterBundle
						};
						next('', mailSendingPackage);
					};
					
					if (
						parameterBundle.inactiveFlag == 'true' ||
						parameterBundle.inactiveFlag === true
					) {
						qtools.logMilestone(
							`inactive template ${parameterBundle.templateName}, forcing zero users`
						);
						localCallback('', []);
					} else {
						this.apiManager.getApi('mailTool.messages.collector.getUserList')(
							parameterBundle,
							localCallback
						);
					}
				}); //get userList for parameterBundle

				emailTasks.push((mailSendingPackage, next) => {
					const messageList = mailSendingPackage.userList.map(user => {
						return userNext => {
							qtools.logDetail(
								`queuing ${user.emailAddress} for ${parameterBundle.templateName}`
							);
							this.apiManager.getApi('mailTool.messages.addMessage')(
								{
									clientRefId: 'mt-sources',
									emailAddress: user.emailAddress,
									templateName: parameterBundle.templateName,
									dictionary: toDictionary(user)
								},
								userNext
							);
						};
					});
					async.parallel(messageList, next);
				}); //queue sending for each user

				asynchronousPipe(emailTasks, parameterBundle, localNext);
			};
		});
		async.series(taskList, err => {
			asyncPipeNext(err, 'finished sending email');
		});
	};

	const executeBatch = () => {
		const taskList = [];
		taskList.push(batchStartNotification);
		taskList.push(checkTemplateDirectory);
		taskList.push(getTemplateFileList);
		taskList.push(buildTemplateList);
		taskList.push(queueMessages);

		asynchronousPipe(taskList, templateDirectoryPath, (err, result) => {
			if (err) {
				qtools.logError(err);
			}
			qtools.logMilestone('finished queuing autoEmail batch');
		});
		return;
	};

	//THE MAIN THING ====================================

	const startSystem = () => {
		later.date.localTime();

		let textSched;
		if (
			this.config.mtMessages.useDebugSchedule &&
			(this.config.mtMessages.useDebugSchedule == 'true' ||
				this.config.mtMessages.useDebugSchedule === true)
		) {
			qtools.logWarn(`using config.mtMessages.useDebugSchedule`);
			textSched = later.parse.text('every 10 seconds');
		} else {
			textSched = later.parse.text(
				this.config.mtMessages.autoEmailSendSchedule
			);
		}

		//const nextEvent = later.schedule(textSched).next();
		const timer2 = later.setInterval(executeBatch, textSched);
	};

	//INITIALIZATION ====================================

	if (typeof this.initCallback == 'function') {
		this.initCallback();
	}

	startSystem(this.initCallback);

	//SHUTDOWN FUNCTIONS ====================================

	this.shutdown = (message, callback) => {
		console.log(`\nshutting down ${__dirname}`);
		callback('', message);
	};

	return this;
};

//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();
