'use strict';
const qtoolsGen = require('qtools');
const qtools = new qtoolsGen(module);
const async = require('async');
const later = require('later');
const multiIni = require('multi-ini');

var nodemailer = require('nodemailer');
var smtpTransport = require('nodemailer-smtp-transport');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'config',
				optional: false
			},
			{
				name: 'database',
				optional: false
			},
			{
				name: 'apiManager',
				optional: true
			},
			{
				name: 'initCallback',
				optional: false
			}
		]
	});

	qtools.validateProperties({
		subject: this.config.mtMessages || {},
		propList: [
			{
				name: 'host',
				optional: false
			},
			{
				name: 'port',
				optional: false
			},
			{
				name: 'user',
				optional: true
			},
			{
				name: 'pass',
				optional: false
			},
			{
				name: 'returnAddress',
				optional: false
			}
		]
	});

	//LOCAL VARIABLES ====================================

	let batchUnderwayLock = false;

	const transportSpecs = this.config.mtMessages;

	var smtpTransport2 = nodemailer.createTransport(
		smtpTransport({
			host: transportSpecs.host,
			secureConnection: true,
			port: transportSpecs.port,
			auth: {
				user: transportSpecs.user,
				pass: transportSpecs.pass
			}
		})
	);

	//LOCAL FUNCTIONS ====================================

	const getTemplate = templateName => {
		const templatePath =
			process.env.srapiProjectPath +
			'configs/emailTemplates/' +
			templateName +
			'.ini';

		if (!qtools.realPath(templatePath)) {
			qtools.logError(`ERROR: no template at ${templatePath}`);
		}

		return multiIni.read(templatePath);
	};

	const applyTemplate = (item, mailConfig) => {
		const transformations = {};

		if (mailConfig.transformations) {
			var self = this;
			for (var i in mailConfig.transformations) {
				var element = mailConfig.transformations[i];
				transformations[i] = eval(element.replace(/\n/g, ' '));
			}
		}

		let replaceObject;
		if (typeof item.toObject == 'function') {
			replaceObject = item.toObject();
		} else {
			replaceObject = qtools.clone(item);
		}

		const dictionary = replaceObject.dictionary ? replaceObject.dictionary : {};



		for (var i = 0, len = dictionary.length; i < len; i++) {
			var element = dictionary[i];
			replaceObject[element.pattern] = element.replacement;
		}
		replaceObject.baseDomain = this.config.system.baseDomain;
		return {
			html: qtools.templateReplace({
				template: mailConfig.templates.html
					? mailConfig.templates.html
					: 'Message from http://<!baseDomain!>',
				replaceObject: replaceObject,
				leaveUnmatchedTagsIntact: false,
				transformations: transformations,
				useSimplePath:true
			}),
			subject: qtools.templateReplace({
				template: mailConfig.templates.subject
					? mailConfig.templates.subject
					: 'Message from <!baseDomain!>',
				replaceObject: replaceObject,
				leaveUnmatchedTagsIntact: false,
				transformations: transformations,
				useSimplePath:true
			}),
			text: qtools.templateReplace({
				template: mailConfig.templates.text
					? mailConfig.templates.text
					: 'Message from http://<!baseDomain!>',
				replaceObject: replaceObject,
				leaveUnmatchedTagsIntact: false,
				transformations: transformations,
				useSimplePath:true
			})
		};
	};

	const clearSentItem = (item, callback) => {
		Message.update(
			{
				refId: item.refId
			},
			{
				completionTime: new Date(),
				sent: true
			},
			{},
			(err, result) => {
				if (err) {
					qtools.logError(err.toString());
					callback(err);
					return;
				}

				callback('', result);
			}
		);
	};

	const fixUpAddresses = config => {
		const outObj = {};
		if (config.ccAddresses) {
			outObj.ccAddresses = qtools.convertNumericObjectToArray(
				config.ccAddresses
			);
		} else {
			outObj.ccAddresses = [];
		}
		if (config.bccAddresses) {
			outObj.bccAddresses = qtools.convertNumericObjectToArray(
				config.bccAddresses
			);
		} else {
			outObj.bccAddresses = [];
		}
		return outObj;
	};

	const generateSmtpConfig = item => {
		const mailConfig = getTemplate(item.templateName);
		
		if (!mailConfig.templates){
			return `${item.templates} has no templates element.`;
		}

		
		if (!mailConfig.templates.subject){
			return `${item.templateName} has no subject element.`;
		}
		
		if (!mailConfig.templates.text){
			return `${item.templateName} has no text element.`;
		}
		
		if (!mailConfig.templates.subject){
			return `${item.templateName} has no html element.`;
		}

		const messageElements = applyTemplate(item, mailConfig);

		const addresses = fixUpAddresses(this.config.mtMessages);

		const mailOptions = {
			from: this.config.mtMessages.returnAddress,

			subject: messageElements.subject,
			text: messageElements.text,
			html: messageElements.html,
			attachmentsXXX: [
				{
					// file on disk as an attachment
					filename: 'text3.txt',
					path: 'Your File path' // stream this file
				}
			]
		};

		mailOptions.originalAddress = item.emailAddress;
		if (
			this.config.mtMessages.sendAllEmailsToAddress &&
			this.config.mtMessages.sendAllEmailsToAddress.match(/@/)
		) {
			mailOptions.to = this.config.mtMessages.sendAllEmailsToAddress;
			qtools.logWarn(
				`ALERT: forcing user email address to be ${this.config.mtMessages.sendAllEmailsToAddress} instead of ${item.emailAddress} (cc, bcc suppresssed per: config.mtMessage.sendAllEmailsToAddress)`
			);
		} else {
			mailOptions.to = item.emailAddress;

			if (
				mailConfig &&
				mailConfig.controls &&
				mailConfig.controls.suppressEmailCopies != 'true' &&
				mailConfig.controls.suppressEmailCopies !== true
			) {
				mailOptions.cc = addresses.ccAddresses;
				mailOptions.bcc = addresses.bccAddresses;
			} else {
				qtools.logWarn(`using config.mtMessages.suppressEmailCopies`);
			}
		}
		return mailOptions;
	};

	const sendEmail = (item, callback) => {
		const localCallback = (err, result) => {
			if (err) {
				qtools.logError(
					`Email send FAILED to ${item.emailAddress} using template ${item.templateName}`
				);
				qtools.logError(err.toString());
			} else {
				const message = result.accepted.join(', ');
				qtools.logMilestone(
					`Sent email to ${message} using template ${item.templateName}`
				);
				clearSentItem(item, callback);
			}
		};
		const mailOptions = generateSmtpConfig(item);
		if (typeof(mailOptions)=='string'){
			localCallback(mailOptions);
		}
		if (
			this.config.mtMessages.suppressEmailSending &&
			(this.config.mtMessages.suppressEmailSending == 'true' ||
				this.config.mtMessages.suppressEmailSending === true)
		) {
			localCallback('', {
				accepted: [
					`NO EMAIL SENT to ${mailOptions.originalAddress} (config.mtMessages.suppressEmailSending==true)`
				]
			});
		} else {
			smtpTransport2.sendMail(mailOptions, localCallback);
		}
	};

	const sendNextBatch = () => {
		if (batchUnderwayLock) {
			qtools.logWarn(
				`batch skipped because previous batch is still processing`
			);
			return;
		}

		Message.find({ sent: false }, (err, result) => {
			if (err) {
				qtools.logError(err.toString());
			}

			if (
				result.length > 0 ||
				this.config.system.baseDomain == 'careplanner.local'
			) {
				qtools.logMilestone(
					`found batch of ${result.length} ready to send messages in queue at ${new Date().toLocaleString()}`
				);
			}

			if (result.length === 0) {
				return;
			}

			batchUnderwayLock = true;
			const taskList = result
				.map(message => message.toObject())
				.map(message => {
					return next => {
						sendEmail(message, (err, result) => {
							if (err) {
								qtools.logError(err.toString());
								return;
							}
							qtools.logMilestone(`completed sending message ${message.refId}`);
							setTimeout(() => {
								next(err, result);
							}, 1000); //throttle email once per second
						});
					};
				});

			qtools.logMilestone(`start sending batch`);
			async.series(taskList, err => {
				if (err) {
					qtools.logError(err.toString());
					return;
				}
				qtools.logMilestone(`completed sending batch`);
				batchUnderwayLock = false;
			});
		});
	};

	//API ENDPOINTS ====================================

	const addMessage = (args, callback) => {
		const { emailAddress, schedule, templateName, dictionary } = args;
		const newMessage = Object.assign({ sent: false }, args);
		newMessage.refId = qtools.newGuid();

		const localCallback = (err, result) => {
			if (err) {
				qtools.logError(err.toString());
				callback(err, result);
				return;
			}

			if (newMessage.immediateFlag) {
				qtools.logDetail(
					`Received immediate email for ${newMessage.emailAddress} using template ${newMessage.templateName}`
				);
				sendEmail(newMessage, callback);
				return;
			}

			callback();
		};
		new Message(newMessage).save(localCallback);

		return true;
	};
	this.apiManager.registerApi('addMessage', addMessage);

	//INITIALIZATION ====================================

	const messageSchema = this.database.Schema({
		refId: {
			type: String,
			unique: true
		},
		clientRefId: String,
		immediateFlag: Boolean,
		templateName: String,
		emailAddress: String,
		completionTime: Date,
		dictionary: [
			{
				pattern: String,
				replacement: String
			}
		],
		sent: Boolean
	},
	{
	  timestamps: true
	});
	const Message = this.database.model('messages', messageSchema);

	const startSystem = () => {
		let localCallback;
		if (this.initCallback) {
			this.initCallback();
		}

		later.date.localTime();

		let textSched;
		if (
			this.config.mtMessages.useDebugSchedule &&
			(this.config.mtMessages.useDebugSchedule == 'true' ||
				this.config.mtMessages.useDebugSchedule === true)
		) {
			qtools.logWarn(`using config.mtMessages.useDebugSchedule`);
			textSched = later.parse.text('every 2 seconds');
		} else {
			textSched = later.parse.text('every 1 minute');
		}

		const nextEvent = later.schedule(textSched).next();
		const timer2 = later.setInterval(sendNextBatch, textSched);
		
		
		if (
			this.config.mtMessages.sendAllEmailsToAddress &&
			this.config.mtMessages.sendAllEmailsToAddress.match(/@/)
		) {
			qtools.logWarn(`using config.mtMessages.sendAllEmailsToAddress`);
		}

		return;
	};
	startSystem();

	//SHUTDOWN FUNCTIONS ====================================

	this.shutdown = (message, callback) => {
		qtools.logMilestone(
			`
shutting down ${__dirname}`
		);
		callback('', message);
	};

	return this;
};

//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();
