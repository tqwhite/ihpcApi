'use strict';
const qtoolsGen = require('qtools');
const qtools = new qtoolsGen(module);
const async = require('async');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'config',
				optional: false
			},
			{
				name: 'database',
				optional: false
			},
			{
				name: 'apiManager',
				optional: false
			},
			{
				name: 'initCallback',
				optional: true
			}
		]
	});
	//LOCAL VARIABLES ====================================

	let workerList = {};

	//LOCAL FUNCTIONS ====================================
	
	const utilGetQueryDataInfo = () => {
		this.apiManager.getApi('databaseApiServer.bookNumbers.users.getList')(
			{},
			(err, users) => {
// 				console.log('\n\n=========================\n\n');
// 				users
// 					.map(item => item.toObject())
// 					.sort(qtools.byObjectProperty('daysSinceSubscribed'))
// 					.forEach(user => {
// 					if (user.username.match(/tq/)){
// 						console.log(
// 							`${user.username} / ${user.emailAddress} / sinceSubscribed: ${user.daysSinceSubscribed} daysLeft: ${user.daysLeftInSubscription}`
// 						);
// 						}
// 					});
// 				console.log('\n\n=========================\n\n');
			}
		);
	};
	utilGetQueryDataInfo();

	const midnight = date => {
		let workingDate;
		if (date == 'today') {
			workingDate = new Date();
		} else {
			workingDate = new Date(date);
		}
		const isInvalid = validateDate(workingDate);
		if (isInvalid) {
			return;
		}
		const dateBits = workingDate.toLocaleDateString('en-US');
		return new Date(dateBits);
	};

	const validateOffset = offset => {
		let invalidTimingMessage;
		if (isNaN(+offset)) {
			invalidTimingMessage = `'${offset}' is not a number`;
		}
		return invalidTimingMessage;
	};

	const validateDate = date => {
		const tmp = new Date(date);
		if (tmp.toString().match(/invalid/i)) {
			return `${date} is not a valid date`;
		}
	};

	const generateOffsetQuery = (propertyName, offset) => {
		const workingDate = dateOfOffsetFromToday(offset);
		const earlierDate = midnight(workingDate);
		const laterDate = midnight(workingDate)
		laterDate.setDate(earlierDate.getDate() + 1); //midnight the day after
		const query = {
			$and: [
				{ [propertyName]: { $gt: earlierDate } },
				{ [propertyName]: { $lte: laterDate } }
			]
		};
		return query;
	};

	const lessThanMonths = (x = 1) => {
		const workingDate = new Date();

		const nextDate = workingDate.getMonth() + x;

		workingDate.setMonth(nextDate);
		const query = {
			lastDayInSubscription: {
				$lt: workingDate
			}
		};

		return query;
	};

	const dateOfOffsetFromToday = dayOffset => {
		const workingDate = new Date();
		const day = workingDate.getDate();
		workingDate.setDate(day + dayOffset);
		return workingDate;
	};
	
	const generateCatchUpQuery = (propertyName, offset) => {
		const workingDate = dateOfOffsetFromToday(offset);
		const earlierDate = midnight(workingDate);
		const laterDate = midnight(workingDate);
		laterDate.setDate(earlierDate.getDate() + 1); //midnight the day after

		const query = {
			[propertyName]: { $lte: laterDate }
		};
		return query;
	};
	
	const validateForExact = timing => {
		const offsetIsValid = validateOffset(timing.offset);
		if (offsetIsValid) {
			return offsetIsValid;
		}

		const startDateIsInvalid = validateDate(timing.startDate);
		if (timing.startDate && startDateIsInvalid) {
			return startDateIsInvalid;
		}

		const endDateIsInvalid = validateDate(timing.endDate);
		if (timing.endDate && endDateIsInvalid) {
			return endDateIsInvalid;
		}

		const { startDate, endDate } = timing;
		const today = midnight('today');
		const start = midnight(startDate || '12/15/1952');
		const end = midnight(endDate || '12/31/2525');

		if (start > today || end < today) {
			return `no email being sent. ${today.toLocaleDateString('en-US')} is outside ${start.toLocaleDateString('en-US')} ${start > today} to ${end.toLocaleDateString('en-US')} ${end < today} interval (measured at midnight)`;
		}
	};

	//QUERY MAP FUNCTIONS ====================================

	const exactDaysUntilExpire = {
		query: timing => {
			const today = midnight('today');
			if (
				timing.sendToThoseWhoMissedWindow &&
				timing.startDate &&
				midnight(timing.startDate).valueOf() == midnight('today').valueOf()
			) {
				return generateCatchUpQuery('lastDayInSubscription', timing.offset);
			} else {
				return generateOffsetQuery('lastDayInSubscription', timing.offset);
			}
		},
		validate: validateForExact
	};

	const exactDaysAfterCreated = {
		query: timing => {
			const today = midnight('today');
			
			if (
				timing.sendToThoseWhoMissedWindow &&
				timing.startDate &&
				midnight(timing.startDate).valueOf() == midnight('today').valueOf()
			) {
				return generateCatchUpQuery('createdAt', -1 * timing.offset);
			} else {
				return generateOffsetQuery('createdAt', -1 * timing.offset);
			}
		},
		validate: validateForExact
	};
	
	const onceToAll = {
		query: timing => {
			return {};
		},
		validate: timing => {
			let outString = '';
			if (!timing.sendDate) {
				return `reference 'once' must have sendDate`;
			}
			if (midnight(timing.sendDate).valueOf() < midnight('today').valueOf()) {
				return `sendDate is ${midnight(timing.sendDate)} in the past. no email queued`;
			}
			if (midnight(timing.sendDate).valueOf() > midnight('today').valueOf()) {
				return `sendDate is ${midnight(timing.sendDate)} in the future. no email queued`;
			}

			return '';
		}
		
	};
	

	//QUERY MANAGEMENT FUNCTIONS ====================================

	const queryMap = {
		lastDayInSubscription: exactDaysUntilExpire,
		createdAt: exactDaysAfterCreated,
		onceToAll: onceToAll
	};

	const validateQuery = timing => {
		if (!queryMap[timing.reference]) {
			return 'no process exists for reference';
		}
		if (queryMap[timing.reference].validate(timing)) {
			return queryMap[timing.reference].validate(timing);
		}
	};

	const generateQuery = timing => {
		const { startDate, endDate } = timing;
		const today = midnight('today');
		const start = midnight(startDate || '12/15/1952');
		const end = midnight(endDate || '12/31/2525');

		return queryMap[timing.reference].query(timing);
	};

	//API FUNCTIONS ====================================

	const getUserList = (parameterBundle, callback) => {
		const timing = parameterBundle.timing ? parameterBundle.timing : {};
		const isInvalid = validateQuery(timing);
		if (isInvalid) {
			callback(
				`invalid timing ${timing.reference}/'${isInvalid}' in mt-collector.js`
			);
			return;
		}

		qtools.logDetail(
			`looking for users meeting ${timing.reference}/${+timing.offset} in mt-collector.js`
		);

		this.apiManager.getApi(
			'databaseApiServer.bookNumbers.users.getList'
		)(generateQuery(timing), (err, users) => {
			if (err) {
				callback({
					code: '500',
					errorText: err
				});
				return;
			}
			if (!users || !users[0]) {
				callback('', []);
				return;
			}

			if (timing.sendToThoseWhoMissedWindow) {
				qtools.logMilestone(
					`found 'sendToThoseWhoMissedWindow', got ${users.length} catch up users`
				);
			}

			callback('', users.map(user => user.toObject()));
		});
	};

	//INITIALIZATION ====================================

	if (typeof this.initCallback == 'function') {
		this.initCallback();
	}

	this.apiManager.registerApi('getUserList', getUserList);

	//SHUTDOWN FUNCTIONS ====================================

	this.shutdown = (message, callback) => {
		console.log(`\nshutting down ${__dirname}`);
		callback('', message);
	};

	return this;
};

//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();
