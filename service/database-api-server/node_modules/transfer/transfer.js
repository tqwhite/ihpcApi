'use strict';
const qtoolsGen = require('qtools');
const qtools = new qtoolsGen(module, { updatePrototypes: true });
const async = require('async');
const asynchronousPipe = require('asynchronous-pipe');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'config',
				optional: false
			},
			{
				name: 'apiManager',
				optional: true
			},
			{
				name: 'router',
				optional: false
			},
			{
				name: 'mongoose',
				optional: false
			},
			{
				name: 'permissionMaster',
				optional: false
			},
			{
				name: 'initCallback',
				optional: false
			}
		]
	});

	//LOCAL VARIABLES ====================================

	//LOCAL FUNCTIONS ====================================

	//METHODS AND PROPERTIES ====================================

	const checkEligibility = (receivingNurseUserName, callback) => {
		const localCallback = (err, result) => {
			let targetUser;

			if (result.refId) {
				targetUser = {
					refId: result.refId,
					first: result.first,
					last: result.last,
					receivingNurseUserName: receivingNurseUserName
				};
			} else {
				targetUser = {
					receivingNurseUserName: receivingNurseUserName
				};
			}
			callback(err, targetUser);
		};

		this.apiManager.getApi(
			'databaseApiServer.bookNumbers.users.getUserIfValid'
		)(receivingNurseUserName, localCallback);
	};

	const saveTransferList = (transferList, callback) => {
		const localCallback = (err, result) => {
			callback(err, result);
		};
		if (!transferList.refId) {
			transferList.refId = qtools.newGuid();
			createTransferRecord(transferList, localCallback);
		} else {
			changeTransferRecord(transferList, localCallback);
		}
	};
	

	const createTransferRecord = (inData, callback) => {
		const taskList = [];
		
		taskList.push((args, next) => {
			const localCallback = (err, localResult1) => {
				args.transferSave = localResult1;
				next(err, args);
			};
			var item = new Transfer(inData);
			item.save(localCallback);
		});
		taskList.push((args, next) => {
			const localCallback = (err, localResult2) => {
				args.localResult2 = localResult2;
				next(err, args);
			};
			const updateStudentList = this.apiManager.getApi(
				'databaseApiServer.bookNumbers.users.session.boilerplate.payment.transfer.students.updateStudentList'
			);
			updateStudentList(
				{
					studentPartialList: inData.studentPartialList || [],
					updateData: { transferStatus: 'pending' }
				},
				localCallback
			);
		});
		
		const initialData = typeof inData != 'undefined' ? inData : {};
		asynchronousPipe(taskList, initialData, (err, finalResult) => {
			callback(err, finalResult.transferSave);
		});
	};
	
	const changeTransferRecord = (inData, callback) => {
		const taskList = [];

		const setTransferStatusAndVisibility=(args, next) => {
			const localCallback = (err, localResult1) => {
				args.updateTransferRec = localResult1;
				next(err, args);
			};

			Transfer.findOne({ refId: inData.refId }, function(err, doc) {
			
			if (doc.status!='pending' && args.inData.status=='accepted'){
				callback(`ERROR: That transfer offer was CANCELLED. Please contact the sending nurse (${args.inData.sendingUserPartial.first} ${args.inData.sendingUserPartial.last})`);
				qtools.logError(`ERROR: That transfer offer was cancelled. It cannot be accepted. Please contact the sending nurse (${args.inData.sendingUserPartial.first} ${args.inData.sendingUserPartial.last} ${args.inData.sendingUserPartial.refId})`);
				return;
			}
			
			
				doc.status = args.inData.status;
				doc.visibility = args.inData.visibility;
				//['accepted', 'rejected'] correspond to constants in ui/transfer.js
				if (['accepted', 'rejected'].includes(args.inData.status)) {
					doc.recipientDecisionDate = new Date();
				}
				doc.save(localCallback);
			});
		}
		const moveStudentsToNewNurse=(args, next) => {
				const localCallback = (err, localResult2) => {
					//no result of this side effect process
					next(err, args);
				};

				const sendingUserRefId =
					args.updateTransferRec.sendingUserPartial.refId;
				const receivingUserRefId =
					args.updateTransferRec.receivingUserPartial.refId;
				const studentPartialList = args.updateTransferRec.studentPartialList;
				const transferRefId = args.updateTransferRec.refId;

				const transferStudents = this.apiManager.getApi(
					'databaseApiServer.bookNumbers.users.session.boilerplate.payment.transfer.students.transferStudents'
				);
				transferStudents(
					{
						sendingUserRefId,
						receivingUserRefId,
						studentPartialList,
						transferRefId
					},
					localCallback
				);
			};
		const tellStudentsTheirNewTransferStatus=(args, next) => {
			const localCallback = (err, localResult2) => {
				args.localResult2 = localResult2;
				next(err, args);
			};
			const updateStudentList = this.apiManager.getApi(
				'databaseApiServer.bookNumbers.users.session.boilerplate.payment.transfer.students.updateStudentList'
			);
			updateStudentList(
				{
					studentPartialList: args.inData.studentPartialList,
					updateData: { transferStatus: args.inData.status }
				},
				localCallback
			);
		}
		
		taskList.push(setTransferStatusAndVisibility);

		if (inData.status == 'accepted') {
			taskList.push(moveStudentsToNewNurse); //side effect on userStudentsAccessSchema
		}

		if (['accepted', 'rejected'].includes(inData.status)) {
			taskList.push(tellStudentsTheirNewTransferStatus); //side effect StudentSchema
		}

		const initialData = { inData: inData };
		asynchronousPipe(taskList, initialData, (err, finalResult) => {
			callback(err, finalResult.updateTransferRec);
		});
	};

	const getTransfersForUser = ({ userRefId, type = 'recipient', callback }) => {
		const localCallback = (err, result) => {
			callback(err, result);
		};

		let query;
		switch (type) {
			case 'sender':
				query = { 'sendingUserPartial.refId': userRefId };
				break;
			case 'recipient':
				query = { 'receivingUserPartial.refId': userRefId };
				query = {
					$and: [
						{ 'receivingUserPartial.refId': userRefId },
						{ status: 'pending' }
					]
				};
				break;
		}

		Transfer.find(query, localCallback);
	};

	//INITIALIZATION ====================================

	this.apiManager.registerApi('getTransfersForUser', getTransfersForUser);

	!this.initCallback || this.initCallback();

	//ECOSYSTEM REQUIREMENTS ====================================

	const ping = (message = 'NO MESSAGE SUPPLIED') => {
		return `${qtools.ping().employer} got the ${message}`;
	};

	this.ping = ping;

	this.shutdown = (message, callback) => {
		console.log(`\nshutting down ${qtools.ping().employer}`);
		callback('', message);
	};

	//API ENDPOINTS ====================================
	//REMEMBER: 'sessions' conducts login.

	let route;
	let method;

	route = new RegExp('transfer/eligibility/(.*?)$');
	method = 'get';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, (req, res, next) => {
		if (req.param[0] && req.tokenJwtDecoded._id !== req.param[0]) {
			next({
				code: '401',
				errorText: 'Unauthorized request'
			});
			return;
		}

		const receivingNurseUserName = req.path.match(
			new RegExp('transfer/eligibility/(.*?)$')
		)[1];

		checkEligibility(receivingNurseUserName, (err, result) => {
			if (err) {
				next({
					code: '400',
					errorText: `${err.toString()}`
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});
	});

	route = new RegExp('transfer');
	method = 'get';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, (req, res, next) => {
		if (req.param[0] && req.tokenJwtDecoded._id !== req.param[0]) {
			next({
				code: '401',
				errorText: 'Unauthorized request'
			});
			return;
		}

		let lookupConstraint = {};
		if (req.params[0] && req.tokenJwtDecoded._id === req.params[0]) {
			lookupConstraint = {
				_id: req.tokenJwtDecoded._id
			};
		}

		retrieveTransferList(lookupConstraint, (err, result) => {
			if (err) {
				next({
					code: '400',
					errorText: `${err.toString()}`
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});
	});

	const extractParametersAndSaveTransfer = (req, res, next) => {
		if (req.param[0] && req.tokenJwtDecoded._id !== req.param[0]) {
			next({
				code: '401',
				errorText: 'Unauthorized request'
			});
			return;
		}

		const inData = req.body;
		const parameter = req.path.match(new RegExp('transfer/(.*?)$'));
		if (parameter) {
			inData.refId = parameter[1];
		}
		saveTransferList(inData, (err, result) => {
			if (err) {
				console.dir({ 'err [transfer.js.moduleFunction]': err });

				next({
					code: '400',
					errorText: `${err.toString()}`
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});
	};

	route = new RegExp('transfer');
	method = 'put';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, extractParametersAndSaveTransfer);

	route = new RegExp('transfer');
	method = 'post';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, extractParametersAndSaveTransfer);

	//SCHEMA ====================================

	const mongoose = this.mongoose;
	const transferSchema = mongoose.Schema(
		{
			visibility: String,
			status: String,
			refId: String,
			recipientDecisionDate: Date,
			sendingUserPartial: {
				refId: String,
				first: String,
				last: String,
				infoPhone: String,
				district: String
			},
			receivingUserPartial: {
				refId: String,
				first: String,
				last: String
			},
			studentPartialList: [
				{
					first: String,
					last: String,
					gradeLevel: String,
					refId: String
				}
			]
		},
		{
			timestamps: true
		}
	);
	//transferSchema.index({ refId: 1, unique: true });

	transferSchema.methods.speak = function() {
		const greeting = this.name
			? 'Meow name is ' + this.name
			: "I don't have a name";
		console.log(greeting);
	};

	transferSchema.methods.toJSON = function() {
		const obj = this.toObject();
		//delete obj.pwhash;
		return obj;
		//thanks Charles
		//http://stackoverflow.com/questions/11160955/how-to-exclude-some-fields-from-the-document
	};

	transferSchema.set('toObject', { virtuals: true });

	transferSchema.set('toJSON', { virtuals: true });

	const Transfer = mongoose.model('Transfer', transferSchema);

	return this;
};
//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();

