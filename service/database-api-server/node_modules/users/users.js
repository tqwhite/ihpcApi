'use strict';
const qtoolsGen = require('qtools');
const qtools = new qtoolsGen(module);
//const crypt=require('crypto');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {

	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'config',
				optional: false
			},
			{
				name: 'router',
				optional: false
			},
			{
				name: 'mongoose',
				optional: false
			},
			{
				name: 'permissionMaster',
				optional: false
			},
			{
				name: 'bookNumbersModel',
				optional: false
			},
			{
				name: 'initCallback',
				optional: false
			}
		]
	});

	//LOCAL VARIABLES ====================================
	const mongoose = this.mongoose;

	//LOCAL FUNCTIONS ====================================

	const getList = (criteria, callback) => {
		User.find(criteria, callback);
	}

	const putItem = (role, id, inData, callback) => {

		if (role && role===this.permissionMaster.getRole('nurse')){
			delete inData.role;
			console.log(`SECURITY ISSUE: Nurse tried to upgrade role. _id=${id} ${new Date()}`);
		}

		if (inData.password){
			inData.pwhash=qtools.passwordHash(inData.password);
		}
		User.update({
			_id: id
		}, inData, {}, callback);
	}

	const postItem = (inData, callback) => {
		if (inData.password){
			inData.pwhash=qtools.passwordHash(inData.password);
		}
		var item = new User(inData);
		item.save(callback);
	}

	const deleteItem = (id, callback) => {
		User.remove({
			_id: id
		}, callback);
	}

	const registerUser = (inData, callback) => {

		this.bookNumbersModel.checkBookNumberAvailability(inData, (err, bookId) => {

			if (err) {
				callback(err);
				return;
			}

			postItem(inData, (err, result) => {

				if (err) {
					callback(err, result);
					return;
				}
				this.bookNumbersModel.updateBookNumber(bookId, result.refId, callback);

			})

		});

		return;
	};
	
	
	const decipher = (confirmationKey) => {
		const crypto = require('crypto');
		const decipher = crypto.createDecipher('aes192', this.config.system.secret);

		var decrypted = '';
		decipher.on('readable', () => {
			var data = decipher.read();
			if (data) {
				decrypted += data.toString('utf8');
			}
		});
		decipher.on('end', () => {

// 			console.log("\n=-=============   =============================  =========================\n");
// 			console.log(confirmationKey);
// 			console.log(decrypted);
// 			console.log("\n=-=============   =============================  =========================\n");

		});

		decipher.write(confirmationKey, 'hex');
		decipher.end();
		
		return decrypted;
	}

	const confirmEmail = (inData, callback) => {

		const userRefId=decipher(inData.confirmationKey);

		const localCallback=(err, result)=>{
			if (!err){
			User.update({_id:result._id}, {emailConfirmationDate:new Date()}, (err2, result2)=>{
				callback('', {message:`Thank You. ${result.emailAddress} is now confirmed.`});
				});
				}
				else{
				callback({errorText:'ERROR! You accessed the confirmEmail API'});
				}
		};



		User.findOne({refId:userRefId}, localCallback);


		return;
	};

	const parseErrorInfo=(err) =>{
		let errorObj;
		let errorText;
		if (err.code=='11000'){
			errorText=err.errmsg.match(/username/);
			const usernameMatch=err.errmsg.match(/dup key: \{ : "(\w+)" \}/);

			if(usernameMatch){

			errorText=errorText?`Username '${errorText}' already exists. Duplicates not allowed.`:err.errmsg;
			}
			else{
			errorText=`Username empty. Must be specified`;
			}

			errorObj={errorText:'server', errorText:errorText};
			return errorObj;
		}

		errorObj={errorText:'server', errorText:err.errmsg};

		return errorObj;
	}

	//METHODS AND PROPERTIES ====================================

	this.shutdown = (message, callback) => {
		console.log(`shutting down ${__dirname}`);
		callback('', message);
	}

	this.getList=getList;

	//API ENDPOINTS ====================================

	let route;
	let method;

	route = new RegExp('(?:user$|user/([A-Za-z0-9]*)$)');
	method='get';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, (req, res, next) => {

		if (req.param[0] && req.tokenJwtDecoded._id!==req.param[0]){

			next({
				code: '401',
				errorText: 'Unauthorized request (users.get())'
			});
			return;
		}

		let lookupConstraint={};
		if (req.params[0] && req.tokenJwtDecoded._id===req.params[0]){
			lookupConstraint={_id:req.tokenJwtDecoded._id};
		}

		getList(lookupConstraint, (err, users) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (users.get())'
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: users
				});
			}
		});

	});

	route = new RegExp('user/(.*)$');
	method='put';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, (req, res, next) => {

		putItem(req.tokenJwtDecoded.role, req.params[0], req.body, (err, result) => {
			if (err) {
				next({
					code: '500',
					errorObject: parseErrorInfo(err),
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});

	});

	route = new RegExp('user$');
	method='post';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, (req, res, next) => {

		postItem(req.body, (err, result) => {
			if (err) {
				next({
					code: '500',
					errorObject: parseErrorInfo(err),
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});

	});

	route = new RegExp('user/register$');
	method='post';
	this.permissionMaster.addRoute(method, route, 'all');
	this.router[method](route, (req, res, next) => {

		registerUser(req.body, (err, result) => {
			if (err) {
				next({
					code: '500',
					errorObject: parseErrorInfo(err),
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});

	});

	route = new RegExp('user/confirmEmail$');
	method='post';
	this.permissionMaster.addRoute(method, route, 'all');
	this.router[method](route, (req, res, next) => { 
		confirmEmail(req.body, (err, result) => {
			if (err) {
				next({
					code: '500',
					errorObject: err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});

	});

	route = new RegExp('user/(.*)$');
	method='delete';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, (req, res, next) => {

		next({
			code: '500',
			errorText: 'Deleting is not allowed at present (user.delete())',
			err: err
		});
		return;
		//=====================
		deleteItem(req.params[0], (err, result) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (user.delete())',
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});

	});

	route = new RegExp('user/reinitialize/(.*)$');
	method='get';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, (req, res, next) => {
		initDb.initializeDb((err, result) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (users.reinitialize()) '+err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});

	});

	//INITIALIZATION ====================================

	const userSchema = mongoose.Schema({
		refId: String,
		first: String,
		last: String,
		username: { type: String, unique: true },
		pwhash: String,
		role: String,
		emailAddress: String,
		isActive: Boolean,
		debugDataVersion: String,
		emailConfirmationDate: Date,

		dictionary:[
					{
						pattern:String,
						replacement:String,
						mandatory:Boolean
					}
				]

	});

	userSchema.methods.speak = function() {
		const greeting = this.name
			? "Meow name is " + this.name
			: "I don't have a name";
		console.log(greeting);
	}

	userSchema.methods.toJSON = function() {
	  const obj = this.toObject()
	  delete obj.pwhash
	  return obj
	  //thanks Charles
	  //http://stackoverflow.com/questions/11160955/how-to-exclude-some-fields-from-the-document
	}

	const User = mongoose.model('User', userSchema);

	const initDbGen = require('user-test-db');
	const initDb = new initDbGen({
		model: User,
		dbName: 'user',
		permissionMaster: this.permissionMaster,
		config:this.config
	});

	this.initCallback();
	return this;
};

//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();

