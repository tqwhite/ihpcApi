"use strict";
const qtoolsGen = require("qtools");
const qtools = new qtoolsGen(module);
//const crypt=require('crypto');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: "config",
				optional: false
			},
			{
				name: "apiManager",
				optional: true
			},
			{
				name: "router",
				optional: false
			},
			{
				name: "mongoose",
				optional: false
			},
			{
				name: "permissionMaster",
				optional: false
			},
			{
				name: "initCallback",
				optional: false
			}
		]
	});

	//LOCAL VARIABLES ====================================
	const mongoose = this.mongoose;

	//LOCAL FUNCTIONS ====================================

	const getList = (criteria, callback) => {
		User.find(criteria, callback);
	};

	const putItem = (role, id, inData, callback) => {
		if (role && role === this.permissionMaster.getRole("nurse")) {
			delete inData.role;
			console.log(
				`SECURITY ISSUE: Nurse tried to upgrade role. _id=${id} ${new Date()}`
			);
		}
		if (inData.password) {
		
		
			if (inData.password.length < 8) {
				callback({
					code: "500",
					errmsg: "Password must be at least eight characters."
				});
				return;
			}

			if (passwordTooCommon(inData['password'], inData['username'], inData['emailAddress'])) {
				callback({
					code: "500",
					errmsg: "Password is too hackable. Choose a better one."
				});
				return;
			}
		
		
			inData.salt=inData.salt?inData.salt:qtools.newGuid();
			inData.pwhash = qtools.passwordHash(inData.password, inData.salt);
		}
		User.update(
			{
				_id: id
			},
			inData,
			{},
			callback
		);
	};

	const setLastLogin = (id, callback) => {
		User.update(
			{
				_id: id
			},
			{
				lastLogin: new Date()
			},
			{},
			callback
		);
	};

	const postItem = (inData, callback) => {
		if (inData.password) {
			inData.salt=inData.salt?inData.salt:qtools.newGuid();
			inData.pwhash = qtools.passwordHash(inData.password, inData.salt);
		}
		if (inData.username) {
			inData.username = inData.username.toLowerCase();
		}
		var item = new User(inData);
		item.save(callback);
	};

	const deleteItem = (id, callback) => {
		User.remove(
			{
				_id: id
			},
			callback
		);
	};
	
	const passwordTooCommon = (password, userName, emailAdr) => {
		const common = [
			"password",
			"12345678",
			"baseball",
			"football",
			"jennifer",
			"superman",
			"trustno1",
			"michelle",
			"sunshine",
			"123456789",
			"starwars",
			"computer",
			"corvette",
			"princess",
			"qwertyuiop",
			userName,
			emailAdr
		];
		const isCommon=common.indexOf(password) > -1;
		const first=password[0];
		const repetition=password.match(new RegExp(first+"{8}"));
		return isCommon || repetition;
	};

	const registerUser = (inData, callback) => {
		if (inData.password.length < 8) {
			callback({
				code: "500",
				errmsg: "Password must be at least eight characters."
			});
			return;
		}

		if (passwordTooCommon(inData['password'], inData['username'], inData['emailAddress'])) {
			callback({
				code: "500",
				errmsg: "Password is too hackable. Choose a better one."
			});
			return;
		}

		this.apiManager.getApi(
			"databaseApiServer.bookNumbers.checkBookNumberAvailability"
		)(inData, (err, bookId) => {
			if (err) {
				callback(err);
				return;
			}
			
			postItem(inData, (err, result) => {
				if (err) {
					callback(err, result);
					return;
				}
				sendEmailToUser(result, "confirmEmail", (err, result2) => {
					this.apiManager.getApi(
						"databaseApiServer.bookNumbers.updateBookNumber"
					)(bookId, result.refId, callback);
				});
			});
		});
		return;
	};

	const confirmEmail = (inData, callback) => {
		const userRefId = decryptForConfirmEmail(inData.confirmationKey).userRefId;

		const localCallback = (err, result) => {
			if (!err) {
				User.update(
					{
						_id: result._id
					},
					{
						emailConfirmationDate: new Date()
					},
					(err2, result2) => {
						callback("", {
							message: `Thank You. ${result.emailAddress} is now confirmed.`
						});
					}
				);
			} else {
				callback({
					errorText: "ERROR! You accessed the confirmEmail API"
				});
			}
		};

		User.findOne(
			{
				refId: userRefId
			},
			localCallback
		);

		return;
	};
	
	const changePassword = (inData, callback) => {
		const goodies = decryptForForgotPassword(inData.changePasswordKey);

		const now = new Date();
		const interval = (now - goodies.startTime) / 1000 / 60;
		const threshold = this.config.system.forgotEmailExpireMinutes
			? this.config.system.forgotEmailExpireMinutes
			: 20;
		if (interval > threshold) {
			callback({
				errorText: "Forgot Password Link has expired."
			});
			return;
		}

		const userRefId = goodies.userRefId;
		
		const localCallback = (err, result) => {
			if (!err) {
				inData.salt=inData.salt?inData.salt:qtools.newGuid();
				User.update(
					{
						_id: result._id
					},
					{
						pwhash: qtools.passwordHash(inData.newPassword, inData.salt),
						salt:inData.salt
					},
					(err2, result2) => {
						callback("", {
							message: (
								`Thank You. The password for ${result.username} is now changed.`
							),
							username: result.username
						});
					}
				);
			} else {
				callback({
					errorText: "ERROR! You accessed the changePassword API"
				});
			}
		};

		User.findOne(
			{
				refId: userRefId
			},
			localCallback
		);

		return;
	};

	const sendEmail = (userRec, template, callback) => {
		const sender = this.apiManager.getApi("mailTool.messages.addMessage");

		if (!userRec) {
			callback("User not found");
			return;
		}

		if (!userRec || !userRec.emailAddress) {
			callback("user.sendEmail() says, Email Address is missing");
			return;
		}

		sender(
			{
				clientRefId: "user.sendEmail",
				emailAddress: userRec.emailAddress,
				schedule: "now",
				templateName: template,
				dictionary: [
					{
						pattern: "first",
						replacement: userRec.first
					},
					{
						pattern: "last",
						replacement: userRec.last
					},
					{
						pattern: "userRefId",
						replacement: userRec.refId
					},
					{
						pattern: "time",
						replacement: new Date()
					},
					{
						pattern: "feedbackMessage",
						replacement: userRec.feedbackMessage
					}
				]
			},
			callback
		);
	};
	
	const sendEmailCallback = (userData, template, callback) => {
		
		return (err, userRec) => {
			if (!err) {
				const internalCallback = (err, dontCareAboutEmailResult) => {
					if (err) {
						callback(err);
						return;
					}
					const emailBits = userRec.emailAddress.match(
						/^(\w).*?(\w)@(\w)\w*(\w)\.(\w\w\w)$/
					);
					
					let obscureEmail;
					
					if (emailBits){
						obscureEmail = `${emailBits[1]}...${emailBits[2]}@${emailBits[
						3
					]}...${emailBits[4]}.${emailBits[5]}`;
					}
					else{
						obscureEmail = userRec.emailAddress;
					}



					callback("", {
						message: `sent email to ${userRec.emailAddress}`,
						obscureEmail: obscureEmail
					});
				};
				sendEmail(userRec, template, internalCallback);
			} else {
				callback({
					errorText: (
						`ERROR! users.sendEmailCallback() says, email ${template} failed.`
					)
				});
			}
		};
	};

	const sendFeedback = (userData, template, callback) => {
		const messageData = Object.assign(
			{},
			{ feedbackMessage: userData.feedbackMessage },
			userData.user
		);
		sendEmail(messageData, "feedback", callback);
		return;
	};
	
	const sendEmailToUser = (userData, template, callback) => {
		let query;
		if (userData.forgotPasswordInfo) {
			query = {
				$or: [
					{
						username: userData.forgotPasswordInfo
					},
					{
						emailAddress: userData.forgotPasswordInfo
					}
				]
			};
			User.findOne(query, sendEmailCallback(userData, template, callback));
		} else {
			query = {
				username: userData.username
			};
			User.findOne(query, sendEmailCallback(userData, template, callback));
		}

		return;
	};

	const parseErrorInfo = err => {
		let errorObj;
		let errorText;
		if (err.code == "11000") {
			errorText = err.errmsg.match(/username/);
			const usernameMatch = err.errmsg.match(/dup key: \{ : "(\w+)" \}/);

			if (usernameMatch) {
				errorText = errorText
					? `Username '${errorText}' already exists. Duplicates not allowed.`
					: err.errmsg;
			} else {
				errorText = `Username empty. Must be specified`;
			}

			errorObj = {
				errorText: "server",
				errorText: errorText
			};
			return errorObj;
		}
		errorObj = {
			errorText: "server",
			errorText: err.errmsg
		};

		return errorObj;
	};
	
	const encipher = inData => {
		const secret = this.config.system.secret;

		const cryptoLocal = require("crypto");

		const cipher = cryptoLocal.createCipher("aes192", secret);
		var encrypted = cipher.update(inData, "utf8", "hex");
		encrypted += cipher.final("hex");

		return encrypted;
	};

	const decipher = confirmationKey => {
		const crypto = require("crypto");
		const decipher = crypto.createDecipher("aes192", this.config.system.secret);

		var decrypted = "";
		decipher.on("readable", () => {
			var data = decipher.read();
			if (data) {
				decrypted += data.toString("utf8");
			}
		});
		decipher.on("end", () => {
			// 			console.log("\n=-=============	 =============================	=========================\n");
			// 			console.log(confirmationKey);
			// 			console.log(decrypted);
			// 			console.log("\n=-=============	 =============================	=========================\n");
		});

		decipher.write(confirmationKey, "hex");
		decipher.end();

		return decrypted;
	};
	
	const separator = "_";
	const encryptForForgotPassword = userData => {
		
		const now = new Date();

		const cipherString = now.toString() + separator + userData.userRefId;
		const encryptedString = encipher(cipherString);
		return encryptedString;
		
	};
	
	const decryptForForgotPassword = inData => {
		const decryptedString = decipher(inData);
		const goodies = decryptedString.split(separator);
		return {
			userRefId: goodies[1],
			startTime: new Date(goodies[0])
		};
		
	};
	
	const encryptForConfirmEmail = userData => {
		//I leave these identical so that emailConfirmationKeys always change
		return encryptForForgotPassword(userData);
		
	};
	
	const decryptForConfirmEmail = inData => {
		//even though I ignore the time stamp
		return decryptForForgotPassword(inData);
		
	};

	//METHODS AND PROPERTIES ====================================

	this.shutdown = (message, callback) => {
		console.log(`shutting down ${__dirname}`);
		callback("", message);
	};

	//API ENDPOINTS ====================================
	//REMEMBER: 'sessions' conducts login.

	let route;
	let method;

	route = new RegExp("/(?:user$|user/([A-Za-z0-9]*)$)");
	method = "get";
	this.permissionMaster.addRoute(method, route, "admin editor nurse");
	this.router[method](route, (req, res, next) => {
		if (req.param[0] && req.tokenJwtDecoded._id !== req.param[0]) {
			next({
				code: "401",
				errorText: "Unauthorized request (users.get())"
			});
			return;
		}

		let lookupConstraint = {};
		if (req.params[0] && req.tokenJwtDecoded._id === req.params[0]) {
			lookupConstraint = {
				_id: req.tokenJwtDecoded._id
			};
		}

		getList(lookupConstraint, (err, users) => {
			if (err) {
				next({
					code: "500",
					errorText: "Database access problem (users.get())"
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: users
				});
			}
		});
	});

	route = new RegExp("user/(.*)$");
	method = "put";
	this.permissionMaster.addRoute(method, route, "admin editor nurse");
	this.router[method](route, (req, res, next) => {
		
		if (req.body.username) {
			req.body.username = req.body.username.toLowerCase();
		}
		
		

		putItem(req.tokenJwtDecoded.role, req.params[0], req.body, (
			err,
			result
		) => {
			if (err) {
				next({
					code: "500",
					errorObject: parseErrorInfo(err),
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});
	});

	route = new RegExp("user$");
	method = "post";
	this.permissionMaster.addRoute(method, route, "admin editor nurse");
	this.router[method](route, (req, res, next) => {
		
		if (req.body.username) {
			req.body.username = req.body.username.toLowerCase();
		}

		postItem(req.body, (err, result) => {
			if (err) {
				next({
					code: "500",
					errorObject: parseErrorInfo(err),
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});
	});

	route = new RegExp("user/register$");
	method = "post";
	this.permissionMaster.addRoute(method, route, "all");
	this.router[method](route, (req, res, next) => {
		registerUser(req.body, (err, result) => {
			if (err) {
				next({
					code: "500",
					errorObject: parseErrorInfo(err),
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});
	});

	route = new RegExp("user/confirmEmail$");
	method = "post";
	this.permissionMaster.addRoute(method, route, "all");
	this.router[method](route, (req, res, next) => {
		confirmEmail(req.body, (err, result) => {
			if (err) {
				next({
					code: "500",
					errorObject: err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});
	});

	route = new RegExp("user/resendEmail$");
	method = "post";
	this.permissionMaster.addRoute(method, route, "all");
	this.router[method](route, (req, res, next) => {
		sendEmailToUser(req.body, "confirmEmail", (err, result) => {
			if (err) {
				next({
					code: "500",
					errorObject: err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});
	});
	
	
	
	
	
	

	route = new RegExp("user/forgotPassword$");
	method = "post";
	this.permissionMaster.addRoute(method, route, "all");
	this.router[method](route, (req, res, next) => {
		sendEmailToUser(req.body, "forgotPassword", (err, result) => {
			if (err) {
				next({
					code: "500",
					errorObject: err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});
	});
	

	route = new RegExp("user/changePassword$");
	method = "post";
	this.permissionMaster.addRoute(method, route, "all");
	this.router[method](route, (req, res, next) => {
		changePassword(req.body, (err, result) => {
			if (err) {
				next({
					code: "500",
					errorObject: err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});
	});
	

	route = new RegExp("user/feedback$");
	method = "post";
	this.permissionMaster.addRoute(method, route, "all");
	this.router[method](route, (req, res, next) => {
		sendFeedback(req.body, "feedback", (err, result) => {
			if (err) {
				next({
					code: "500",
					errorObject: err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});
	});		 
	 route = new RegExp("user/(.*)$");
	method = "delete";
	this.permissionMaster.addRoute(method, route, "admin editor nurse");
	this.router[method](route, (req, res, next) => {
		next({
			code: "500",
			errorText: "Deleting is not allowed at present (user.delete())",
			err: err
		});
		return;
		//=====================
		deleteItem(req.params[0], (err, result) => {
			if (err) {
				next({
					code: "500",
					errorText: "Database access problem (user.delete())",
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});
	});

	route = new RegExp("/user/reinitialize/(.*)$");
	method = "get";
	this.permissionMaster.addRoute(method, route, "admin editor nurse");
	this.router[method](route, (req, res, next) => {
		initDb.initializeDb((err, result) => {
			if (err) {
				next({
					code: "500",
					errorText: "Database access problem (users.reinitialize()) " + err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});
	});

	//INITIALIZATION ====================================

	this.apiManager.registerApi("getList", getList);
	this.apiManager.registerApi(
		"encryptForForgotPassword",
		encryptForForgotPassword
	);
	this.apiManager.registerApi("encryptForConfirmEmail", encryptForConfirmEmail);
	this.apiManager.registerApi("setLastLogin", setLastLogin);

	//remember that some dictionary items have default values defined in the UI/app.js
	const userSchema = mongoose.Schema({
		refId: String,
		first: String,
		last: String,
		username: {
			type: String,
			unique: true
		},
		pwhash: String,
		salt: String,
		role: String,
		emailAddress: String,
		isActive: Boolean,
		debugDataVersion: String,
		emailConfirmationDate: Date,
		lastLogin: Date,

		dictionary: [
			{
				pattern: String,
				replacement: String,
				mandatory: Boolean
			}
		]
	});
	
	userSchema.index({ username: 1 });
	userSchema.index({ refId: 1, unique: true });
	
	userSchema.methods.speak = function() {
		const greeting = this.name
			? "Meow name is " + this.name
			: "I don't have a name";
		console.log(greeting);
	};

	userSchema.methods.toJSON = function() {
		const obj = this.toObject();
		delete obj.pwhash;
		return obj;
		//thanks Charles
		//http://stackoverflow.com/questions/11160955/how-to-exclude-some-fields-from-the-document
	};

	const User = mongoose.model("User", userSchema);

	const initDbGen = require("user-test-db");
	const initDb = new initDbGen({
		model: User,
		dbName: "user",
		permissionMaster: this.permissionMaster,
		config: this.config
	});

	this.initCallback();
	return this;
};

//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();

