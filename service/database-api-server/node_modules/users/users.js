'use strict';
const qtoolsGen = require('qtools');
const qtools = new qtoolsGen(module);
//const crypt=require('crypto');
const asynchronousPipe = require('asynchronous-pipe');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'config',
				optional: false
			},
			{
				name: 'apiManager',
				optional: true
			},
			{
				name: 'router',
				optional: false
			},
			{
				name: 'mongoose',
				optional: false
			},
			{
				name: 'permissionMaster',
				optional: false
			},
			{
				name: 'initCallback',
				optional: false
			}
		]
	});

	//LOCAL VARIABLES ====================================
	const mongoose = this.mongoose;

	//LOCAL FUNCTIONS ====================================

	const getList = (criteria, callback) => {
		User.find(criteria, callback);
	};
	//
	// NExt:
	// implement the redemption code for both
	// update the forgotPassword template with new code
	// do home email address

	const putItem = (role, id, inData, callback) => {
		if (role && role === this.permissionMaster.getRole('nurse')) {
			delete inData.role;
			console.log(
				`SECURITY ISSUE: Nurse tried to upgrade role. _id=${id} ${new Date()}`
			);
		}
		if (inData.password) {
			if (inData.password.length < 8) {
				callback({
					code: '500',
					errmsg: 'Password must be at least eight characters.'
				});
				return;
			}

			if (
				passwordTooCommon(
					inData['password'],
					inData['username'],
					inData['emailAddress']
				)
			) {
				callback({
					code: '500',
					errmsg: 'Password is too hackable. Choose a better one.'
				});
				return;
			}

			inData.salt = inData.salt ? inData.salt : qtools.newGuid();
			inData.pwhash = qtools.passwordHash(inData.password, inData.salt);
		}
		delete inData.createdAt;
		User.update(
			{
				_id: id
			},
			inData,
			{},
			callback
		);
	};

	const setLastLogin = (id, callback) => {
		User.update(
			{
				_id: id
			},
			{
				lastLogin: new Date()
			},
			{},
			callback
		);
	};

	const incrementExpiration = (user, months, callback) => {
		const today = new Date();
		const lastDayInSubscription = new Date(user.lastDayInSubscription);

		const workingDate =
			lastDayInSubscription > today ? lastDayInSubscription : today;

		const nextDate = workingDate.getDate() + months * (365 / 12);
		workingDate.setDate(nextDate);
		const newDate = workingDate.toLocaleString();
		User.update(
			{
				refId: user.refId
			},
			{
				lastDayInSubscription: newDate
			},
			{},
			(err, result) => {
				callback('', {
					newDate: newDate,
					months: months
				});
			}
		);
	};

	const updateSubscription = (user, updateSubscriptionToken, callback) => {
		//see note explaining strangeness between booknumber.number and transactionID in book-numbers.js
		const tokenBits = updateSubscriptionToken.split('_');
		if (!this.config.storeData[tokenBits[0]]) {
			callback(
				{
					errMsg: `The purchase token is invalid. There is no such store as ${
						tokenBits[0]
					}.`
				},
				''
			);
			return;
		}
		const tokenDetails = decryptForUpdateSubscription(
			tokenBits[2],
			this.config.storeData[tokenBits[0]].secret,
			tokenBits[1]
		);
		if (!tokenDetails) {
			callback(
				{
					errMsg:
						'The purchase token is an invalid format. Perhaps some characters are missing.'
				},
				''
			);
			return;
		}
		qtools.logDetail(
			'tokenDetails=' +
				tokenDetails.join(',') +
				' [users.js.updateSubscription()]'
		);
		const months = tokenDetails[1];
		const localCallback = (err, result) => {
			if (err) {
				callback(err, result);
				return;
			}
			incrementExpiration(user, months, callback);
		};
		this.apiManager.getApi('databaseApiServer.bookNumbers.recordTransaction')(
			{
				number: tokenDetails[0],
				months: months,
				role: tokenDetails[2],
				category: tokenDetails[4],
				userRefId: user.refId
			},
			localCallback
		);
	};

	const postItem = (inData, callback) => {
		if (inData.password) {
			inData.salt = inData.salt ? inData.salt : qtools.newGuid();
			inData.pwhash = qtools.passwordHash(inData.password, inData.salt);
		}
		if (inData.username) {
			inData.username = inData.username.toLowerCase();
		}
		var item = new User(inData);
		item.save(callback);
	};

	const deleteItem = (id, callback) => {
		User.remove(
			{
				_id: id
			},
			callback
		);
	};

	const passwordTooCommon = (password, userName, emailAdr) => {
		const common = [
			'password',
			'12345678',
			'baseball',
			'football',
			'jennifer',
			'superman',
			'trustno1',
			'michelle',
			'sunshine',
			'123456789',
			'starwars',
			'computer',
			'corvette',
			'princess',
			'qwertyuiop',
			userName,
			emailAdr
		];
		const isCommon = common.indexOf(password) > -1;
		const first = password[0];
		const repetition = password.match(new RegExp(first + '{8}'));
		return isCommon || repetition;
	};

	const registerUser = (inData, callback) => {
		if (inData.password.length < 8) {
			callback({
				code: '500',
				errmsg: 'Password must be at least eight characters.'
			});
			return;
		}

		if (
			passwordTooCommon(
				inData['password'],
				inData['username'],
				inData['emailAddress']
			)
		) {
			callback({
				code: '500',
				errmsg: 'Password is too hackable. Choose a better one.'
			});
			return;
		}

		this.apiManager.getApi(
			'databaseApiServer.bookNumbers.checkBookNumberAvailability'
		)(inData, (err, bookId) => {
			if (err) {
				callback(err);
				return;
			}
			const months = this.config.defaults.initialSubscriptionMonths;
			if (!inData.lastDayInSubscription) {
				const date = new Date();
				const nextDate = date.getDate() + months * (365 / 12);
				date.setDate(nextDate);
				const newDate = date.toLocaleString();
				inData.lastDayInSubscription = newDate;
			}

			postItem(inData, (err, result) => {
				if (err) {
					callback(err, result);
					return;
				}
				sendEmailToUser(result, 'confirmEmail', (err, result2) => {
					this.apiManager.getApi(
						'databaseApiServer.bookNumbers.updateBookNumber'
					)(bookId, result.refId, callback);
				});
			});
		});
		return;
	};

	const confirmEmail = (inData, callback) => {
		const localCallback = (err, result) => {
			if (!result) {
				qtools.logError(
					'ERROR! The confirmation URL is incorrect. Perhaps a copy/paste error.'
				);
				callback({
					errorText:
						'ERROR! The confirmation URL is incorrect. Perhaps a copy/paste error.'
				});
				return;
			}

			if (!err) {
				User.update(
					{
						_id: result._id
					},
					{
						emailConfirmationDate: new Date()
					},
					(err2, result2) => {
						callback('', {
							message: `Thank You. ${result.emailAddress} is now confirmed.`
						});
					}
				);
			} else {
				callback({
					errorText: 'ERROR! You accessed the confirmEmail API'
				});
			}
		};

		User.findOne(
			{
				emailConfirmationToken: inData.confirmationKey
			},
			localCallback
		);

		return;
	};

	const changePassword = (inData, callback) => {
		const localCallback = (err, result) => {
			if (err) {
				callback({
					errorText: err.toString() + ' users/changePassword'
				});
				return;
			}

			if (!result) {
				callback({
					errorText:
						'Invalid password reset URL code. Please request a new one.'
				});
				return;
			}

			const now = new Date();
			const interval = (now - result.forgotPasswordExpiration) / 1000 / 60;
			const threshold = this.config.system.forgotEmailExpireMinutes
				? this.config.system.forgotEmailExpireMinutes
				: 20;

			if (interval > threshold) {
				callback({
					errorText: 'Forgot Password Link has expired.'
				});
				return;
			} else {
				inData.salt = inData.salt ? inData.salt : qtools.newGuid();
				User.update(
					{
						_id: result._id
					},
					{
						pwhash: qtools.passwordHash(inData.newPassword, inData.salt),
						salt: inData.salt,
						forgotPasswordExpiration: ''
					},
					(err2, result2) => {
						callback('', {
							message: `Thank You. The password for ${
								result.username
							} is now changed.`,
							username: result.username
						});
					}
				);
			}
		};

		User.findOne(
			{
				forgotPasswordToken: inData.changePasswordKey
			},
			localCallback
		);

		return;
	};

	const sendEmail = (userRec, template, callback) => {
		const sender = this.apiManager.getApi('mailTool.messages.addMessage');

		if (!userRec) {
			callback('User not found');
			return;
		}

		if (!userRec || !userRec.emailAddress) {
			callback('user.sendEmail() says, Email Address is missing');
			return;
		}

		const emailAddress = userRec.emailAddressSecondary
			? `${userRec.emailAddress},${userRec.emailAddressSecondary}`
			: userRec.emailAddress;

		console.dir({ 'emailAddress [users.js.moduleFunction]': emailAddress });

		sender(
			{
				clientRefId: 'user.sendEmail',
				emailAddress: emailAddress,
				immediateFlag: true,
				templateName: template,
				dictionary: [
					{
						pattern: 'first',
						replacement: userRec.first
					},
					{
						pattern: 'last',
						replacement: userRec.last
					},
					{
						pattern: 'userRefId',
						replacement: userRec.refId
					},
					{
						pattern: 'time',
						replacement: new Date()
					},
					{
						pattern: 'feedbackMessage',
						replacement: userRec.feedbackMessage
					}
				]
			},
			callback
		);
	};

	const getSendEmailCallback = (template, callback) => {
		return (err, userRec) => {
			if (!err) {
				const internalCallback = (err, dontCareAboutEmailResult) => {
					if (err) {
						callback(err);
						return;
					}

					const emailBits = userRec.emailAddress.match(
						/^(\w).*?(\w)@(\w\w).*(\w\w)\.(\w\w|\w\w\w)$/
					);

					let obscureEmail;

					if (emailBits) {
						obscureEmail = `${emailBits[1]}...${emailBits[2]}@${
							emailBits[3]
						}...${emailBits[4]}.${emailBits[5]}`;
					} else {
						obscureEmail = userRec.emailAddress;
					}

					if (userRec.emailAddressSecondary) {
						const emailBits = userRec.emailAddressSecondary.match(
							/^(\w).*?(\w)@(\w\w).*(\w\w)\.(\w\w|\w\w\w)$/
						);

						if (emailBits) {
							obscureEmail += ` AND to ${emailBits[1]}...${emailBits[2]}@${
								emailBits[3]
							}...${emailBits[4]}.${emailBits[5]}`;
						} else {
							obscureEmail += ` AND to ${userRec.emailAddressSecondary}`;
						}
					}

					callback('', {
						message: `sent email to ${userRec.emailAddress} and  ${
							userRec.emailAddressSecondary
						} (if any)`,
						obscureEmail: obscureEmail
					});
				};
				sendEmail(userRec, template, internalCallback);
			} else {
				callback({
					errorText: `ERROR! users.sendEmailCallback() says, email ${template} failed.`
				});
			}
		};
	};

	const sendFeedback = (userData, template, callback) => {
		const messageData = Object.assign(
			{},
			{ feedbackMessage: userData.feedbackMessage },
			userData.user
		);
		sendEmail(messageData, 'feedback', callback);
		return;
	};

	const localCallback = (err, result) => {
		const decipher = this.apiManager.getApi(
			'webInit.dispatch.utilityServer.decipher'
		);

		databaseApiServer.bookNumbers.users.session.boilerplate.payment.transfer
			.getTransfers;
	};
	
	const asynchronousPipe = require('asynchronous-pipe');

	const getUserComplete = (userData, callback) => {
		let query;
		if (userData.forgotPasswordInfo) {
			query = {
				$or: [
					{
						username: userData.forgotPasswordInfo
					},
					{
						emailAddress: userData.forgotPasswordInfo
					},
					{
						emailAddressSecondary: userData.forgotPasswordInfo
					}
				]
			};
		} else {
			query = {
				username: userData.username
			};
		}

		const taskList = [];

		taskList.push((args, next) => {
			const localCallback = (err, localResult1) => {
				args.user = localResult1;
				next(err, args);
			};

			User.findOne(query, localCallback);
		});
		taskList.push((args, next) => {
			const localCallback = (err, localResult2) => {
				args.transfersRecipient = localResult2;
				next(err, args);
			};
			
			if (!args.user){
				next('', args); //no user found is not an error but requires no subesquent retrieving
				return;
			}
			
			const decipher = this.apiManager.getApi(
				'databaseApiServer.bookNumbers.users.session.boilerplate.payment.transfer.getTransfersForUser'
			)({
				userRefId: args.user.refId,
				type: 'recipient',
				callback: localCallback
			});
		});
		taskList.push((args, next) => {
			const localCallback = (err, localResult2) => {
				args.transfersSender = localResult2;
				next(err, args);
			};
			
			if (!args.user){
				next('', args); //no user found is not an error but requires no subesquent retrieving
				return;
			}

			const decipher = this.apiManager.getApi(
				'databaseApiServer.bookNumbers.users.session.boilerplate.payment.transfer.getTransfersForUser'
			)({
				userRefId: args.user.refId,
				type: 'sender',
				callback: localCallback
			});
		});

		const initialData = typeof inData != 'undefined' ? inData : {};
		asynchronousPipe(taskList, initialData, (err, finalResult) => {
			
			if (!finalResult.user){
				callback(); //no user found is not an error but requires no subesquent retrieving
				return;
			}
			
			const user = finalResult.user;
			user.transfersRecipient = finalResult.transfersRecipient; //to send these to user via session, they are added explicitly in sessions.js
			user.transfersSender = finalResult.transfersSender; //to send these to user via session, they are added explicitly in sessions.js
			user.offers = finalResult.offers;
			callback(err, user);
		});
	};

	
	const getUserData = (userData, template, callback) => {
		let query;
		if (userData.forgotPasswordInfo) {
			query = {
				$or: [
					{
						username: userData.forgotPasswordInfo
					},
					{
						emailAddress: userData.forgotPasswordInfo
					},
					{
						emailAddressSecondary: userData.forgotPasswordInfo
					}
				]
			};
			User.findOne(query, callback);
		} else {
			query = {
				username: userData.username
			};
			User.findOne(query, callback);
		}
		return;
	};
	
	const getUserIfValid = (potentialUsername, callback) => {
		const localCallback = (err, user) => {
			user = user ? user.toObject() : {};
			const validCalc =
				user &&
				user.isActive &&
				new Date(user.lastDayInSubscription) > new Date()
					? true
					: false;

			if (!validCalc) {
				qtools.logWarn(
					`getUserIfValid(): potentialUsername=${potentialUsername}, user.isActive=${
						user.isActive
					}, user.lastDayInSubscription=${
						user.lastDayInSubscription
					}, today=${new Date()}`
				);
			}
			if (validCalc) {
				callback(err, user);
			} else {
				let property;
				property = 'receivingNurseUserName';
				user[property] = user[property] ? user[property] : property;
				callback(err, user);
			}
		};

		getUserData({ username: new RegExp(`^${potentialUsername}$`, 'i') }, '', localCallback);
	};

	const parseErrorInfo = err => {
		let errorObj;
		let errorText;
		if (err.code == '11000') {
			errorText = err.errmsg.match(/username/);
			const usernameMatch = err.errmsg.match(/dup key: \{ : "(\w+)" \}/);

			if (usernameMatch) {
				errorText = errorText
					? `Username '${errorText}' already exists. Duplicates not allowed.`
					: err.errmsg;
			} else {
				errorText = `Username empty. Must be specified`;
			}

			errorObj = {
				errorText: 'server',
				errorText: errorText
			};
			return errorObj;
		}
		errorObj = {
			errorText: 'server',
			errorText: err.errmsg
		};

		return errorObj;
	};

	const decryptForUpdateSubscription = (inData, secret, salt) => {
		const separator = '_';

		const decipher = this.apiManager.getApi(
			'webInit.dispatch.utilityServer.decipher'
		);

		const decryptedString = decipher(inData, secret, salt);

		if (typeof decryptedString != 'string') {
			return '';
		}
		const goodies = decryptedString.split(separator);
		return goodies;
	};

	const sendEmailToUser = (userData, template, callback) => {
		const taskList = [];

		taskList.push((args, next) => {
			const localCallback = (err, userData) => {
				args.userData = userData;
				next(err, args);
			};
			getUserData(userData, template, localCallback);
		});

		const initialData = typeof inData != 'undefined' ? inData : {};
		asynchronousPipe(taskList, initialData, (err, finalResult) => {
			//note: I refactored this on the way to a different solution and changed
			//my mind about the strategy. This is better than it was and
			//I should have reorganized this silly construction since
			//it's no longer needed. But, I don't want to take the time. tqii
			getSendEmailCallback(template, callback)(err, finalResult.userData);
		});
	};
	
	const getAcumentAccountId = (criteria, callback) => {
		const taskList = [];

		taskList.push((args, next) => {
			const localCallback = (err, userList) => {
				if (userList && userList[0] && userList[0].acumenAccountId) {
					args.hash = userList[0].acumenAccountId;
				}
				next(err, args);
			};

			getList(criteria, localCallback);
		});

		taskList.push((args, next) => {
			const localCallback = (err, acumenAccountId) => {
				next(err, acumenAccountId);
			};

			if (!args.hash) {
				getUrlToken(criteria, 'acumenAccountId', localCallback);
			} else {
				localCallback('', args.hash);
			}
		});

		const initialData = typeof inData != 'undefined' ? inData : {};
		asynchronousPipe(taskList, initialData, (err, acumenAccountId) => {
			callback(err, acumenAccountId); //this is heading to a template that wants a single value
		});
	};

	const getUrlToken = (criteria, type, callback) => {
		if (
			![
				'forgotPasswordToken',
				'emailConfirmationToken',
				'acumenAccountId'
			].includes(type)
		) {
			callback(`invalid type, ${type}, in users/getUrlToken`); //tq demonstrated that this message is passed all the way back to the browser but not displayed
			return;
		}

		const taskList = [];

		taskList.push((args, next) => {
			args.hash = qtools.newId();
			next('', args);
		});
		taskList.push((args, next) => {
			const localCallback = (err, duplicateHash) => {
				if (duplicateHash.length) {
					getUrlToken(criteria, type, callback); //cannot imagine how this could recurse forever
					return;
				}

				next(err, args);
			};

			getList({ [type]: args.hash }, localCallback);
		});

		taskList.push((args, next) => {
			const localCallback = (err, inData) => {
				next(err, args);
			};
			const update = {
				[type]: args.hash
			}; //update sends this as $set

			if (type == 'forgotPasswordToken') {
				update.forgotPasswordExpiration = new Date();
			}
			User.update(criteria, update, {}, localCallback);
		});

		const initialData = typeof inData != 'undefined' ? inData : {};
		asynchronousPipe(taskList, initialData, (err, finalResult) => {
			callback(err, finalResult.hash);
		});
	};

	//METHODS AND PROPERTIES ====================================

	this.shutdown = (message, callback) => {
		console.log(`shutting down ${__dirname}`);
		callback('', message);
	};

	//API ENDPOINTS ====================================
	//REMEMBER: 'sessions' conducts login.

	let route;
	let method;

	route = new RegExp('/(?:user$|user/([A-Za-z0-9]*)$)');
	method = 'get';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, (req, res, next) => {
		if (req.param[0] && req.tokenJwtDecoded._id !== req.param[0]) {
			next({
				code: '401',
				errorText: 'Unauthorized request (users.get())'
			});
			return;
		}

		let lookupConstraint = {};
		if (req.params[0] && req.tokenJwtDecoded._id === req.params[0]) {
			lookupConstraint = {
				_id: req.tokenJwtDecoded._id
			};
		}

		getList(lookupConstraint, (err, users) => {
			const claims = {
				userRefId: users[0].refId,
				lastDayInSubscription: users[0].lastDayInSubscription,
				databaseName: this.config.database.displayName,
				_id: users[0]._id
			};

			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (users.get())'
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req, claims),
					data: users
				});
			}
		});
	});

	route = new RegExp('user/(.*)$');
	method = 'put';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, (req, res, next) => {
		if (req.body.username) {
			req.body.username = req.body.username.toLowerCase();
		}

		putItem(
			req.tokenJwtDecoded.role,
			req.params[0],
			req.body,
			(err, result) => {
				if (err) {
					next({
						code: '500',
						errorObject: parseErrorInfo(err),
						err: err
					});
				} else {
					res.json({
						token: this.permissionMaster.updateToken(req),
						data: result
					});
				}
			}
		);
	});

	route = new RegExp('user$');
	method = 'post';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, (req, res, next) => {
		if (req.body.username) {
			req.body.username = req.body.username.toLowerCase();
		}

		postItem(req.body, (err, result) => {
			if (err) {
				next({
					code: '500',
					errorObject: parseErrorInfo(err),
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});
	});

	route = new RegExp('user/register$');
	method = 'post';
	this.permissionMaster.addRoute(method, route, 'all');
	this.router[method](route, (req, res, next) => {
		registerUser(req.body, (err, result) => {
			if (err) {
				next({
					code: '500',
					errorObject: parseErrorInfo(err),
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});
	});

	route = new RegExp('user/confirmEmail$');
	method = 'post';
	this.permissionMaster.addRoute(method, route, 'all');
	this.router[method](route, (req, res, next) => {
		confirmEmail(req.body, (err, result) => {
			if (err) {
				next({
					code: '500',
					errorObject: err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});
	});

	route = new RegExp('user/resendEmail$');
	method = 'post';
	this.permissionMaster.addRoute(method, route, 'all');
	this.router[method](route, (req, res, next) => {
		sendEmailToUser(req.body, 'confirmEmail', (err, result) => {
			if (err) {
				next({
					code: '500',
					errorObject: err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});
	});

	route = new RegExp('user/forgotPassword$');
	method = 'post';
	this.permissionMaster.addRoute(method, route, 'all');
	this.router[method](route, (req, res, next) => {
		sendEmailToUser(req.body, 'forgotPassword', (err, result) => {
			if (err) {
				next({
					code: '500',
					errorObject: err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});
	});

	route = new RegExp('user/changePassword$');
	method = 'post';
	this.permissionMaster.addRoute(method, route, 'all');
	this.router[method](route, (req, res, next) => {
		changePassword(req.body, (err, result) => {
			if (err) {
				next({
					code: '500',
					errorObject: err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});
	});

	route = new RegExp('user/feedback$');
	method = 'post';
	this.permissionMaster.addRoute(method, route, 'all');
	this.router[method](route, (req, res, next) => {
		sendFeedback(req.body, 'feedback', (err, result) => {
			if (err) {
				next({
					code: '500',
					errorObject: err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: [result]
				});
			}
		});
	});
	route = new RegExp('user/(.*)$');
	method = 'delete';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, (req, res, next) => {
		next({
			code: '500',
			errorText: 'Deleting is not allowed at present (user.delete())',
			err: err
		});
		return;
		//=====================
		deleteItem(req.params[0], (err, result) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (user.delete())',
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});
	});

	route = new RegExp('/user/NEVERUSEDAGAIN/(.*)$');
	method = 'get';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, (req, res, next) => {
		initDb.initializeDb((err, result) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (users.reinitialize()) ' + err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});
	});

	//INITIALIZATION ====================================

	this.apiManager.registerApi('getList', getList);
	this.apiManager.registerApi('getUserComplete', getUserComplete);
	this.apiManager.registerApi('getUrlToken', getUrlToken);
	this.apiManager.registerApi('getAcumentAccountId', getAcumentAccountId);
	this.apiManager.registerApi('setLastLogin', setLastLogin);
	this.apiManager.registerApi('updateSubscription', updateSubscription);
	this.apiManager.registerApi('incrementExpiration', incrementExpiration); //refers to subscription, used by payment process
	this.apiManager.registerApi('getUserIfValid', getUserIfValid);

	//remember that some dictionary items have default values defined in the UI/app.js
	const userSchema = mongoose.Schema(
		{
			refId: String,
			first: String,
			last: String,
			username: {
				type: String,
				unique: true
			},
			pwhash: String,
			salt: String,
			role: String,
			emailAddress: String,
			emailAddressSecondary: String,
			isActive: Boolean,
			debugDataVersion: String,
			emailConfirmationDate: Date,
			lastLogin: Date,
			lastDayInSubscription: Date,
			emailConfirmationToken: String,
			acumenAccountId: String,
			forgotPasswordToken: String,
			forgotPasswordExpiration: Date,
			purchaseHistory: [
				{
					purchaseDate: Date,
					invoiceNumber: String,
					daysPurchased: String
				}
			],

			dictionary: [
				{
					pattern: String,
					replacement: String,
					mandatory: Boolean
				}
			]
		},
		{
			timestamps: true
		}
	);

	userSchema.index({ username: 1 });
	userSchema.index({ refId: 1, unique: true });

	userSchema.methods.speak = function() {
		const greeting = this.name
			? 'Meow name is ' + this.name
			: "I don't have a name";
		console.log(greeting);
	};

	userSchema.methods.toJSON = function() {
		const obj = this.toObject();
		delete obj.pwhash;
		return obj;
		//thanks Charles
		//http://stackoverflow.com/questions/11160955/how-to-exclude-some-fields-from-the-document
	};

	userSchema.set('toObject', { virtuals: true });

	userSchema.set('toJSON', { virtuals: true });

	const midnightToday = () => {
		const today = new Date();
		return new Date(today.getUTCFullYear(), today.getMonth(), today.getDate());
	};

	userSchema.virtual('daysSinceSubscribed').get(function() {
		return Math.ceil((midnightToday() - this.createdAt) / 86400000); //milliseconds/day
	});

	userSchema.virtual('daysLeftInSubscription').get(function() {
		return Math.floor(
			(this.lastDayInSubscription - midnightToday()) / 86400000
		); //milliseconds/day
	});

	const User = mongoose.model('User', userSchema);

	// 	const initDbGen = require('user-test-db');
	// 	const initDb = new initDbGen({
	// 		model: User,
	// 		dbName: 'user',
	// 		permissionMaster: this.permissionMaster,
	// 		config: this.config
	// 	});

	this.initCallback();
	return this;
};

//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();
