'use strict';
const qtoolsGen = require('qtools');
const qtools = new qtoolsGen(module, { updatePrototypes: true });
const async = require('async');
const asynchronousPipe = require('asynchronous-pipe');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'config',
				optional: false
			},
			{
				name: 'apiManager',
				optional: true
			},
			{
				name: 'router',
				optional: false
			},
			{
				name: 'mongoose',
				optional: false
			},
			{
				name: 'permissionMaster',
				optional: false
			},
			{
				name: 'initCallback',
				optional: false
			}
		]
	});

	//LOCAL VARIABLES ====================================

	//LOCAL FUNCTIONS ====================================

	//METHODS AND PROPERTIES ====================================

	const checkEligibility = (receivingNurseUserName, callback) => {
		const localCallback = (err, result) => {
			let targetUser;

			if (result && result.refId) {
				targetUser = {
					refId: result.refId,
					first: result.first,
					last: result.last,
					receivingNurseUserName: receivingNurseUserName
				};
			} else {
				targetUser = {
					receivingNurseUserName: receivingNurseUserName
				};
			}
			callback(err, targetUser);
		};

		this.apiManager.getApi(
			'databaseApiServer.bookNumbers.users.getUserIfValid'
		)(receivingNurseUserName, localCallback);
	};

	const saveDistrictList = (transferList, callback) => {
		const localCallback = (err, result) => {
			callback(err, result);
		};
		if (!transferList.refId) {
			transferList.refId = qtools.newGuid();
			createDistrictRecord(transferList, localCallback);
		} else {
			changeDistrictRecord(transferList, localCallback);
		}
	};
	

	const createDistrictRecord = (inData, callback) => {
		const taskList = [];
		
		taskList.push((args, next) => {
			const localCallback = (err, localResult1) => {
				args.transferSave = localResult1;
				next(err, args);
			};
			var item = new District(inData);
			item.save(localCallback);
		});
		taskList.push((args, next) => {
			const localCallback = (err, localResult2) => {
				args.localResult2 = localResult2;
				next(err, args);
			};
			const updateStudentList = this.apiManager.getApi(
				'databaseApiServer.bookNumbers.users.session.boilerplate.payment.transfer.students.updateStudentList'
			);
			updateStudentList(
				{
					studentPartialList: inData.studentPartialList || [],
					updateData: { transferStatus: 'pending' }
				},
				localCallback
			);
		});
		
		const initialData = typeof inData != 'undefined' ? inData : {};
		asynchronousPipe(taskList, initialData, (err, finalResult) => {
			callback(err, finalResult.transferSave);
		});
	};
	
	const changeDistrictRecord = (inData, callback) => {
		const taskList = [];

		const setDistrictStatusAndVisibility=(args, next) => {
			const localCallback = (err, localResult1) => {
				args.updateDistrictRec = localResult1;
				next(err, args);
			};

			District.findOne({ refId: inData.refId }, function(err, doc) {
			
			if (doc.status=='cancelled' && args.inData.status=='accepted'){
				callback(`ERROR: That transfer offer was CANCELLED. Please contact the sending nurse (${doc.sendingUserPartial.first} ${doc.sendingUserPartial.last})`);
				qtools.logError(`ERROR: That transfer offer was cancelled. It cannot be accepted. Please contact the sending nurse (${doc.sendingUserPartial.first} ${doc.sendingUserPartial.last} ${doc.sendingUserPartial.refId})`);
				return;
			}
			
			if (doc.status=='accepted' && args.inData.status=='cancelled'){
				callback(`ERROR: That transfer offer has ALREADY BEEN ACCEPTED. Please contact the receiving nurse (${doc.receivingUserPartial.first} ${doc.sendingUserPartial.last})`);
				qtools.logError(`ERROR: That transfer offer has ALREADY BEEN ACCEPTED. Please contact the receiving nurse (${doc.receivingUserPartial.first} ${doc.sendingUserPartial.last}) ${doc.sendingUserPartial.refId})`);
				return;
			}
			
			
				doc.status = args.inData.status;
				doc.visibility = args.inData.visibility;
				//['accepted', 'rejected'] correspond to constants in ui/district.js
				if (['accepted', 'rejected'].includes(args.inData.status)) {
					doc.recipientDecisionDate = new Date();
				}
				doc.save(localCallback);
			});
		}
		const moveStudentsToNewNurse=(args, next) => {
				const localCallback = (err, localResult2) => {
					//no result of this side effect process
					next(err, args);
				};

				const sendingUserRefId =
					args.updateDistrictRec.sendingUserPartial.refId;
				const receivingUserRefId =
					args.updateDistrictRec.receivingUserPartial.refId;
				const studentPartialList = args.updateDistrictRec.studentPartialList;
				const transferRefId = args.updateDistrictRec.refId;

				const transferStudents = this.apiManager.getApi(
					'databaseApiServer.bookNumbers.users.session.boilerplate.payment.transfer.students.transferStudents'
				);
				transferStudents(
					{
						sendingUserRefId,
						receivingUserRefId,
						studentPartialList,
						transferRefId
					},
					localCallback
				);
			};
		const tellStudentsTheirNewDistrictStatus=(args, next) => {
			const localCallback = (err, localResult2) => {
				args.localResult2 = localResult2;
				next(err, args);
			};
			const updateStudentList = this.apiManager.getApi(
				'databaseApiServer.bookNumbers.users.session.boilerplate.payment.transfer.students.updateStudentList'
			);
			updateStudentList(
				{
					studentPartialList: args.inData.studentPartialList || [],
					updateData: { transferStatus: args.inData.status }
				},
				localCallback
			);
		}
		
		taskList.push(setDistrictStatusAndVisibility);

		if (inData.status == 'accepted') {
			taskList.push(moveStudentsToNewNurse); //side effect on userStudentsAccessSchema
		}

		if (['accepted', 'rejected'].includes(inData.status)) {
			taskList.push(tellStudentsTheirNewDistrictStatus); //side effect StudentSchema
		}

		const initialData = { inData: inData };
		asynchronousPipe(taskList, initialData, (err, finalResult) => {
			callback(err, finalResult.updateDistrictRec);
		});
	};

	const getDistrictsForUser = ({ userRefId, type = 'recipient', callback }) => {
		const localCallback = (err, result) => {
			callback(err, result);
		};

		let query;
		switch (type) {
			case 'sender':
				query = { 'sendingUserPartial.refId': userRefId };
				break;
			case 'recipient':
				query = { 'receivingUserPartial.refId': userRefId };
				query = {
					$and: [
						{ 'receivingUserPartial.refId': userRefId },
						{ status: 'pending' }
					]
				};
				break;
		}

		District.find(query, localCallback);
	};

	//INITIALIZATION ====================================

	this.apiManager.registerApi('getDistrictsForUser', getDistrictsForUser);

	!this.initCallback || this.initCallback();

	//ECOSYSTEM REQUIREMENTS ====================================

	const ping = (message = 'NO MESSAGE SUPPLIED') => {
		return `${qtools.ping().employer} got the ${message}`;
	};

	this.ping = ping;

	this.shutdown = (message, callback) => {
		console.log(`\nshutting down ${qtools.ping().employer}`);
		callback('', message);
	};

	//API ENDPOINTS ====================================
	//REMEMBER: 'sessions' conducts login.

	let route;
	let method;

	route = new RegExp('district');
	method = 'get';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, (req, res, next) => {
		if (req.param[0] && req.tokenJwtDecoded._id !== req.param[0]) {
			next({
				code: '401',
				errorText: 'Unauthorized request'
			});
			return;
		}

		let lookupConstraint = {};
		if (req.params[0] && req.tokenJwtDecoded._id === req.params[0]) {
			lookupConstraint = {
				_id: req.tokenJwtDecoded._id
			};
		}

		retrieveDistrictList(lookupConstraint, (err, result) => {
			if (err) {
				next({
					code: '400',
					errorText: `${err.toString()}`
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});
	});

	const extractParametersAndSaveDistrict = (req, res, next) => {
		if (req.param[0] && req.tokenJwtDecoded._id !== req.param[0]) {
			next({
				code: '401',
				errorText: 'Unauthorized request'
			});
			return;
		}

		const inData = req.body;
		const parameter = req.path.match(new RegExp('transfer/(.*?)$'));
		if (parameter) {
			inData.refId = parameter[1];
		}
		saveDistrictList(inData, (err, result) => {
			if (err) {
				console.dir({ 'err [district.js.moduleFunction]': err });

				next({
					code: '400',
					errorText: `${err.toString()}`
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});
	};

	route = new RegExp('district');
	method = 'put';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, extractParametersAndSaveDistrict);

	route = new RegExp('district');
	method = 'post';
	this.permissionMaster.addRoute(method, route, 'admin editor nurse');
	this.router[method](route, extractParametersAndSaveDistrict);

	//SCHEMA ====================================

	const mongoose = this.mongoose;
	const districtSchema = mongoose.Schema(
		{
			active: Boolean,
			urlPathName: String,
			displayName: String,
			refId: String,
			ssoParameters: {
				url: String
			}
		},
		{
			timestamps: true
		}
	);
	//districtSchema.index({ refId: 1, unique: true });

	districtSchema.methods.speak = function() {
		const greeting = this.name
			? 'Meow name is ' + this.name
			: "I don't have a name";
		console.log(greeting);
	};

	districtSchema.methods.toJSON = function() {
		const obj = this.toObject();
		//delete obj.pwhash;
		return obj;
		//thanks Charles
		//http://stackoverflow.com/questions/11160955/how-to-exclude-some-fields-from-the-document
	};

	districtSchema.set('toObject', { virtuals: true });

	districtSchema.set('toJSON', { virtuals: true });

	const District = mongoose.model('District', districtSchema);

	return this;
};
//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();

