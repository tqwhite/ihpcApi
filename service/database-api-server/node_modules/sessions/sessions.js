'use strict';

const moduleName = __filename.replace(__dirname + '/', '').replace(/.js$/, ''); //this just seems to come in handy a lot
//const projectRoot=fs.realpathSync(path.join(__dirname, '..', '..')); // adjust the number of '..' to fit reality

const qtoolsGen = require('qtools');
const qtools = new qtoolsGen(module);
const qt = require('qtools-functional-library'); //also exposes qtLog(); qt.help({printOutput:true, queryString:'.*', sendJson:false});

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'singleSignOn',
				optional: false
			},
			{
				name: 'config',
				optional: false
			},
			{
				name: 'apiManager',
				optional: true
			},
			{
				name: 'router',
				optional: false
			},
			{
				name: 'permissionMaster',
				optional: false
			},
			{
				name: 'initCallback',
				optional: false
			}
		]
	});
	

	//LOCAL VARIABLES ====================================

	//LOCAL FUNCTIONS ====================================

	//METHODS AND PROPERTIES ====================================

	this.shutdown = (message, callback) => {
		console.log(
			`
		shutting down ${__dirname}`
		);
		callback('', message);
	};

	//API ENDPOINTS ====================================

	let route;
	let method;

	route = new RegExp('session/keepAlive$');
	method = 'get';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {
		res.json({
			token: this.permissionMaster.updateToken(req),
			data: {}
		});
	});

	route = new RegExp('session$');
	method = 'post';
	this.permissionMaster.addRoute(method, route, 'all');
	this.router[method](route, async (req, res, next) => {
		let userName = qtools.getSurePath(req, 'body.user.username');
		let password = qtools.getSurePath(req, 'body.user.password');
		const ssoToken = qtools.getSurePath(req, 'body.user.ssoToken'); //signal if we are doing SSO

		const updateSubscriptionToken = qtools.getSurePath(
			req,
			'body.updateSubscriptionToken'
		);

		const senduserObjectession = async (userObject, metaData, ssoProvider) => {
			//remember that the token is updated by permissionMaster.js on subsequent cycles
			const role = userObject.role;
			const claims = {
				userRefId: userObject.refId,
				lastDayInSubscription: userObject.lastDayInSubscription,
				databaseName: this.config.database.displayName,
				_id: userObject._id
			};

			if (userObject.district) {
				const ssoResult = ssoProvider.getRedirectUrl({
					ssoParameters: userObject.district.ssoParameters
				});
				userObject.district.logoutUrl = ssoResult.logoutUrl;
			}

			res.json({
				token: this.permissionMaster.getToken(role, claims),
				data: {
					users: userObject,
					transfersRecipient: userObject.transfersRecipient, //transfers are not forwarded by user model json converter
					transfersSender: userObject.transfersSender, //transfers are not forwarded by user model json converter
					metaData: metaData,
					configuration: this.config.userInterface
				}
			});
		};

		// ------------------------------------------------------------------------
		// GET USER DATA FROM DIStRICT IDENTITY PROVIDER BASED ON req.path

		const processingSsoToken = ssoToken != undefined;

		let ssoProvider;

		if (processingSsoToken) {
			const singleSignOnInstance = this.singleSignOn();
			const tmp = await singleSignOnInstance.getProvider(
				req.qtGetSurePath('body.user.districtId')
			);
			ssoProvider = tmp.ssoProvider;

			const ssoResult = await ssoProvider
				.getUserIdentity({
					req
				})
				.catch(error => {
					next({
						code: '500',
						errorText: error.toString()
					});
					return {};
				});

			userName = ssoResult.userName;
			password = ssoResult.password;
			if (!userName) {
				return;
			}
		} else {
			console.log(`no SSO token [${moduleName}]`);
		}
		// ------------------------------------------------------------------------

		if (userName) {
			this.apiManager.getApi(
				'databaseApiServer.bookNumbers.users.getUserComplete'
			)(
				{
					username: userName.toLowerCase()
				},
				async (err, userResult) => {
					const userObject = userResult;
					// -------------------------------------
					if (err) {
						next({
							code: '500',
							errorText: err
						});
						return;
					}
					if (!userObject) {
						next({
							code: '500',
							errorText: `No such user`
						});
						return;
					}

					// -------------------------------------

					const sendingSsoRedirectInfoToUi =
						userObject.districtRefId && !processingSsoToken;

					if (sendingSsoRedirectInfoToUi) {
						const district = userObject.district;

						const singleSignOnInstance = this.singleSignOn();
						const tmp = await singleSignOnInstance.getProvider(
							district.districtId
						);
						ssoProvider = tmp.ssoProvider;

						const { redirectUrl } = ssoProvider.getRedirectUrl({
							ssoParameters: district.ssoParameters
						});

						const errorText = redirectUrl;
						next({
							code: '302',
							errorText
						});
						return;
					}

					// -------------------------------------
					if (!userObject) {
						next({
							code: '401',
							errorText: `User name ${userName} not found`
						});
						return;
					}

					// -------------------------------------
					if (!userObject.role) {
						next({
							code: '401',
							errorText: "User's Role is not Supported"
						});
						return;
					}

					// -------------------------------------
					if (!userObject.isActive) {
						next({
							code: '401',
							errorText: 'User is not active'
						});
						return;
					}

					// -------------------------------------
					if (!userObject.pwhash) {
						next({
							code: '401',
							errorText: 'Invalid User Name or PasswordX'
						});
						return;
					}

					// -------------------------------------
					if (
						!processingSsoToken &&
						userObject.pwhash != qtools.passwordHash(password, userObject.salt)
					) {
						next({
							code: '401',
							errorText: 'Invalid User Name or PasswordY'
						});
						return;
					}

					// -------------------------------------
					const wrapItUp = (userObject, result) => {
						this.apiManager.getApi(
							'databaseApiServer.bookNumbers.users.setLastLogin'
						)(userObject._id, () => {
							if (result && result.months) {
								this.apiManager.getApi(
									'databaseApiServer.bookNumbers.users.getUserComplete'
								)(
									{
										username: userObject.username.toLowerCase()
									},
									(err, userObject) => {
										senduserObjectession(userObject, {
											updateSubscriptionResult: result,
											ssoProvider
										});
									}
								);
							} else {
								senduserObjectession(userObject, '', ssoProvider);
							}
						});
					};

					// -------------------------------------
					if (updateSubscriptionToken) {
						this.apiManager.getApi(
							'databaseApiServer.bookNumbers.users.updateSubscription'
						)(userObject, updateSubscriptionToken, (err, result) => {
							if (err) {
								next({
									code: '401',
									errorText: err.errMsg
								});
								return;
							}
							wrapItUp(userObject, result);
						});
					} else {
						wrapItUp(userObject);
					}
				}
			);
		} else {
			next({
				code: 404,
				errorText: 'Invalid User Name or Password'
			});
		}
	});
	//INITIALIZATION ====================================
	this.initCallback();
	return this;
};

//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();
