'use strict';
const qtoolsGen = require('qtools');
const qtools = new qtoolsGen(module);
//const crypt=require('crypto');
const async = require('async');
const asynchronousPipe = require('asynchronous-pipe');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'config',
				optional: false
			},
			{
				name: 'apiManager',
				optional: true
			},
			{
				name: 'router',
				optional: false
			},
			{
				name: 'mongoose',
				optional: false
			},
			{
				name: 'permissionMaster',
				optional: false
			},
			{
				name: 'initCallback',
				optional: false
			}
		]
	});

	//LOCAL VARIABLES ====================================
	const mongoose = this.mongoose;

	//LOCAL FUNCTIONS ====================================

	//METHODS AND PROPERTIES ====================================

	this.shutdown = (message, callback) => {
		console.log(`shutting down ${__dirname}`);
		callback('', message);
	};

	const getAccessList = (criteria, callback) => {
		UserStudentsAccessModel.find(criteria, callback);
	};

	const getList = (criteria, callback) => {
		Student.find(criteria, callback).sort([
			['last', 'ascending'],
			['first', 'ascending']
		]);
	};

	const putItem = function(id, inData, callback) {
		delete inData.createdAt;
		Student.update(
			{
				_id: id
			},
			inData,
			{},
			callback
		);
	};
	
	const updateStudentList=({studentPartialList, updateData}, callback)=>{
		const localCallback=(err, result)=>{
			callback(err, result);
		}
		const values=studentPartialList.map(item=>item.refId);
		Student.update({refId:{$in:values}}, {$set:updateData}, {multi:true}, localCallback);
	}

	const postItem = function(inData, callback) {
		var item = new Student(inData);
		item.save(callback);
	};

	const postAccessItem = function(inData, callback) {
		var item = new UserStudentsAccessModel(inData);
		item.save(callback);
	};

	const deleteItem = function(id, callback) {
		Student.remove(
			{
				_id: id
			},
			callback
		);
	};

	const newAccessItem = (inData, userRefId) => {
		return {
			refId: qtools.newGuid(),
			userRefId: userRefId,
			studentRefIdList: [inData.refId]
		};
	};  
	
	const transferOneStudent = (
		{ sendingUserRefId, receivingUserRefId, studentRefId, transferRefId },
		callback
	) => {
		//moves one student from one nurse's **UserStudentsAccessModel** to another one
		//does NOT change the student record itself
		const taskList = [];

		taskList.push((args, next) => {
			const localCallback = (err, localResult1) => {
				args.senderAccessDoc = localResult1;
				next(err, args);
			};

			UserStudentsAccessModel.findOne(
				{ userRefId: args.sendingUserRefId },
				localCallback
			);
		});
		taskList.push((args, next) => {
			const localCallback = (err, localResult2) => {
				args.receiverAccessDoc = localResult2?localResult2:initUserStudentAccess(args.receivingUserRefId);
				next(err, args);
			};

			UserStudentsAccessModel.findOne(
				{ userRefId: args.receivingUserRefId },
				localCallback
			);
		});
		taskList.push((args, next) => {
			const localCallback = (err, localResult2) => {
				args.transferredStudentRefId = localResult2;
				next(err, args);
			};

			const tmp = args.senderAccessDoc.studentRefIdList.filter(
				item => args.studentRefId != item
			); 
			 args.senderAccessDoc.studentRefIdList = tmp;
			args.receiverAccessDoc.studentRefIdList.push(args.studentRefId);
			args.senderAccessDoc.transferSendingRefIdList.includes(transferRefId) ||
				args.senderAccessDoc.transferSendingRefIdList.push(transferRefId);
			args.receiverAccessDoc.transferReceivingRefIdList.includes(
				transferRefId
			) ||
				args.receiverAccessDoc.transferReceivingRefIdList.push(transferRefId);

			localCallback('', args.studentRefId);
		});
		taskList.push((args, next) => {
			const localCallback = (err, localResult2) => {
				args.receiverNewObject = localResult2;
				next(err, args);
			};
			args.receiverAccessDoc.save(localCallback);
		});
		taskList.push((args, next) => {
			const localCallback = (err, localResult2) => {
				args.senderNewObject = localResult2;
				next(err, args);
			};
			args.senderAccessDoc.save(localCallback);
		});

		const initialData = {
			sendingUserRefId,
			receivingUserRefId,
			studentRefId,
			transferRefId
		};
		asynchronousPipe(taskList, initialData, (err, finalResult) => {
			callback(err, finalResult.transferredStudentRefId);
		});
	};

	const transferStudents = (
		//moves a list of students from one teachers UserStudentsAccessModel to another's
		{ sendingUserRefId, receivingUserRefId, studentPartialList, transferRefId },
		callback
	) => {

		const taskList = studentPartialList
			.toObject()
			.map(studentPartial => (args, next) => {
				const localCallback = (err, localResult1) => {
					args.transferredStudentsRefIdList.push(localResult1);
					next(err, args);
				};

				transferOneStudent(
					{
						sendingUserRefId,
						receivingUserRefId,
						studentRefId: studentPartial.refId,
						transferRefId: args.transferRefId
					},
					localCallback
				);
			});

		const initialData = {
			sendingUserRefId,
			receivingUserRefId,
			transferRefId,
			transferredStudentsRefIdList: []
		};
		asynchronousPipe(taskList, initialData, (err, finalResult) => {
			callback(err, finalResult);
		});
	};
	//API ENDPOINTS ====================================
	let route;
	let method;

	route = new RegExp('/student$');
	method = 'get';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {
		//	const constraint={userRefId:req.tokenJwtDecoded.userRefId};
		const taskList = [];
		const accessList = [];
		taskList.push(asyncNext => {
			getAccessList(
				{ userRefId: req.tokenJwtDecoded.userRefId },
				(err, result) => {
					if (err) {
						asyncNext({
							code: '500',
							errorText: 'Database access problem (student.get())',
							err: err
						});
					} else {
						if (typeof result[0] != 'undefined') {
							result[0].studentRefIdList.map(item => {
								accessList.push(item);
							});
						}
						asyncNext();
					}
				}
			);
		});

		taskList.push(asyncNext => {
			getList({ refId: { $in: accessList } }, (err, users) => {
				if (err) {
					asyncNext({
						code: '500',
						errorText: 'Database access problem (student.get())',
						err: err
					});
				} else {
					res.json({
						token: this.permissionMaster.updateToken(req),
						data: users,
						accessList: accessList
					});
				}
			});
		});

		async.series(taskList, next);
	});

	route = new RegExp('student/(.*)$');
	method = 'put';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {
		putItem(req.params[0], req.body, (err, result) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (student.put())',
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});
	});

	route = new RegExp('student$');
	method = 'post';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {
		const taskList = [];
		let accessItem;
		let skipAccessWrite = false;
		taskList.push(asyncNext => {
			getAccessList(
				{ userRefId: req.tokenJwtDecoded.userRefId },
				(err, result) => {
					if (err) {
						asyncNext({
							code: '500',
							errorText: 'Database access problem (student.get())',
							err: err
						});
					} else {
						if (typeof result[0] != 'undefined') {
							accessItem = result[0];

							if (accessItem.studentRefIdList.indexOf(req.body.refId) > -1) {
								skipAccessWrite = true;
								next();
								return;
							}

							accessItem.studentRefIdList.push(req.body.refId);

						} else {
							accessItem = newAccessItem(
								req.body,
								req.tokenJwtDecoded.userRefId
							);
						}
						asyncNext();
					}
				}
			);
		});

		taskList.push(asyncNext => {
			if (skipAccessWrite) {
				asyncNext();
				return;
			}
			postAccessItem(accessItem, asyncNext);
		});

		taskList.push(asyncNext => {
			postItem(req.body, (err, result) => {
				if (err) {
					asyncNext({
						code: '500',
						errorText: 'Database access problem (student.post())',
						err: err
					});
				} else {
					res.json({
						token: this.permissionMaster.updateToken(req),
						data: [result]
					});
				}
			});
		});

		async.series(taskList, next);

	});

	route = new RegExp('student/(.*)$');
	method = 'delete';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {
		deleteItem(req.params[0], (err, result) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (student.delete())',
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});
	});

	route = new RegExp('/student/reinitialize/(.*)$');
	method = 'get';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {
		initDb.initializeDb((err, result) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (student.reinitialize()) ' + err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});
	});

	//INITIALIZATION ====================================

	this.apiManager.registerApi('transferStudents', transferStudents);
	this.apiManager.registerApi('updateStudentList', updateStudentList);

	const studentSchema = mongoose.Schema(
		{
			debugDataVersion: String,
			refId: String,
			first: String,
			middle: String,
			last: String,
			street1: String,
			street2: String,
			city: String,
			state: String,
			zip: String,
			phone: String,
			emailAddress: String,
			birthday: String,
			gradeLevel: String,
			gender: String,
			idNumber: String,
			school: String,
			teacher: String,
			hcOneName: String,
			hcOnePhone: String,
			hcOneEmailAdr: String,
			hcTwoName: String,
			hcTwoPhone: String,
			hcTwoEmailAdr: String,
			icdCode: String,
			icdCodingSystem: String,
			iep: String,
			eep: String,
			'504plan': String,
			eap: String,
			nurseNote: String,
			gOneRelationship: String,
			gOneName: String,
			gOneEmailAdr: String,
			gOnePhoneMain: String,
			gOnePhoneAlt: String,
			gOneEmailAdr: String,
			gOneStreet1: String,
			gOneStreet2: String,
			gOneCity: String,
			gOneState: String,
			gOneZip: String,
			gTwoRelationship: String,
			gTwoName: String,
			gTwoEmailAdr: String,
			gTwoPhoneMain: String,
			gTwoPhoneAlt: String,
			gTwoEmailAdr: String,
			gTwoStreet1: String,
			gTwoStreet2: String,
			gTwoCity: String,
			gTwoState: String,
			gTwoZip: String,
			inactive: Boolean,
			transferStatus: String
		},
		{
			timestamps: true
		}
	);

	studentSchema.index({ refId: 1, unique: true });

	const userStudentsAccessSchema = mongoose.Schema(
		{
			refId: String,
			userRefId: String,
			transferReceivingRefIdList: [String],
			transferSendingRefIdList: [String],
			studentRefIdList: [String]
		},
		{
			timestamps: true
		}
	);

	userStudentsAccessSchema.index({ refId: 1, unique: true });
	userStudentsAccessSchema.index({ userRefId: 1 });

	const Student = mongoose.model('Student', studentSchema);
	const UserStudentsAccessModel = mongoose.model(
		'userStudentsAccess',
		userStudentsAccessSchema
	);
	
	const initUserStudentAccess=(userRefId)=>{
		return new UserStudentsAccessModel({
			refId : qtools.newGuid(),
			userRefId : userRefId,
			studentRefIdList : [],
			transferReceivingRefIdList : [],
			transferSendingRefIdList : []
		});
	}

	// 	const initDbGen = require('students-test-db');
	// 	const initDb = new initDbGen({
	// 		oneToManyAccessModel: UserStudentsAccessModel,
	// 		oneToManyAccessModelName: 'userStudentsAccess',
	// 		model: Student,
	// 		dbName: 'student',
	// 		config: this.config
	// 	});

	this.initCallback();
	return this;
};

//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();

