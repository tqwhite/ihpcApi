'use strict';
const qtoolsGen = require('qtools');
const qtools = new qtoolsGen(module);
//const crypt=require('crypto');
const async = require('async');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {

	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'config',
				optional: false
			},
			{
				name: 'router',
				optional: false
			},
			{
				name: 'mongoose',
				optional: false
			},
			{
				name: 'permissionMaster',
				optional: false
			},
			{
				name: 'initCallback',
				optional: false
			}
		]
	});

	//LOCAL VARIABLES ====================================
	const mongoose = this.mongoose;

	//LOCAL FUNCTIONS ====================================

	//METHODS AND PROPERTIES ====================================

	this.shutdown = (message, callback) => {
		console.log(`shutting down ${__dirname}`);
		callback('', message);
	}

	const getAccessList = (criteria, callback) => {
		UserStudentsAccessModel.find(criteria, callback);

	}

	const getList = (criteria, callback) => {
		Student.find(criteria, callback)
		.sort([['last', 'ascending'],['first', 'ascending']]);

	}

	const putItem = function(id, inData, callback) {
		Student.update({
			_id: id
		}, inData, {}, callback);
	}

	const postItem = function(inData, callback) {
		var item = new Student(inData);
		item.save(callback);
	}

	const postAccessItem = function(inData, callback) {
		var item = new UserStudentsAccessModel(inData);
		item.save(callback);
	}

	const deleteItem = function(id, callback) {
		Student.remove({
			_id: id
		}, callback);
	}

	const newAccessItem=(inData, userRefId)=>{
		return {
				refId:qtools.newGuid(),
				userRefId:userRefId,
				studentRefIdList:[inData.refId]
			}
	}

	//API ENDPOINTS ====================================
	let route;
	let method;

	route = new RegExp('/student$');
	method='get';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {
		//	const constraint={userRefId:req.tokenJwtDecoded.userRefId};
		const taskList = [];
		const accessList=[];
		taskList.push((asyncNext) => {
			getAccessList({userRefId:req.tokenJwtDecoded.userRefId}, (err, result) => {
				if (err) {
					asyncNext({
						code: '500',
						errorText: 'Database access problem (student.get())',
						err: err
					});
				} else {
				if (typeof(result[0])!='undefined'){
					result[0].studentRefIdList.map((item)=>{
						accessList.push(item)
					});
					}
					asyncNext();
				}
			});
		});
		
		
		
		taskList.push((asyncNext) => {
			getList({refId: {$in: accessList}}, (err, users) => {
				if (err) {
					asyncNext({
						code: '500',
						errorText: 'Database access problem (student.get())',
						err: err
					});
				} else {
					res.json({
						token: this.permissionMaster.updateToken(req),
						data: users,
						accessList:accessList
					});
				}
			});
		});

		async.series(taskList, next);

	});

	route = new RegExp('student/(.*)$');
	method='put';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {

		putItem(req.params[0], req.body, (err, result) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (student.put())',
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});

	});

	route = new RegExp('student$');
	method='post';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {

		const taskList=[];
		let accessItem;
		let skipAccessWrite=false;
		taskList.push((asyncNext) => {
			getAccessList({userRefId:req.tokenJwtDecoded.userRefId}, (err, result) => {
				if (err) {
					asyncNext({
						code: '500',
						errorText: 'Database access problem (student.get())',
						err: err
					});
				} else {
				if (typeof(result[0])!='undefined'){

						accessItem=result[0];
						
						if (accessItem.studentRefIdList.indexOf(req.body.refId)>-1){
							skipAccessWrite=true;
							next();
							return;
						}
						
						accessItem.studentRefIdList.push(req.body.refId);


					}
					else{
						accessItem=newAccessItem(req.body, req.tokenJwtDecoded.userRefId);
					}
					asyncNext();
				}
			});
		});
		
	
		taskList.push((asyncNext)=>{
			if (skipAccessWrite){
				asyncNext();
				return;
			}
			postAccessItem(accessItem, asyncNext);
		});
		
		taskList.push((asyncNext) => {
			postItem(req.body, (err, result) => {
				if (err) {
					asyncNext({
						code: '500',
						errorText: 'Database access problem (student.post())',
						err: err
					});
				} else {
					res.json({
						token: this.permissionMaster.updateToken(req),
						data: [result]
					});
				}
			});
		});

		async.series(taskList, next);


	});

	route = new RegExp('student/(.*)$');
	method='delete';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {

		deleteItem(req.params[0], (err, result) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (student.delete())',
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});

	});

	route = new RegExp('/student/reinitialize/(.*)$');
	method='get';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {
		initDb.initializeDb((err, result) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (student.reinitialize()) ' + err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});

	});

	//INITIALIZATION ====================================

	const studentSchema = mongoose.Schema({
		debugDataVersion: String,
		refId: String,
		first: String,
		middle: String,
		last: String,
		street1: String,
		street2: String,
		city: String,
		state: String,
		zip: String,
		phone: String,
		emailAddress: String,
		birthday: String,
		gradeLevel: String,
		gender: String,
		idNumber: String,
		school: String,
		teacher: String,
		hcOneName: String,
		hcOnePhone: String,
		hcOneEmailAdr: String,
		hcTwoName: String,
		hcTwoPhone: String,
		hcTwoEmailAdr: String,
		IDC9CM: String,
		iep: String,
		eep: String,
		'504plan': String,
		eap: String,
		gOneRelationship: String,
		gOneName: String,
		gOnePhoneMain: String,
		gOnePhoneAlt: String,
		gOneEmailAdr: String,
		gOneStreet1: String,
		gOneStreet2: String,
		gOneCity: String,
		gOneState: String,
		gOneZip: String,
		gTwoRelationship: String,
		gTwoName: String,
		gTwoPhoneMain: String,
		gTwoPhoneAlt: String,
		gTwoEmailAdr: String,
		gTwoStreet1: String,
		gTwoStreet2: String,
		gTwoCity: String,
		gTwoState: String,
		gTwoZip: String,

	},
	{
	  timestamps: true
	});
	
	studentSchema.index({refId: 1, unique:true});

	const userStudentsAccessSchema = mongoose.Schema({
		refId: String,
		userRefId: String,
		studentRefIdList: [String]
	},
	{
	  timestamps: true
	});
	
	userStudentsAccessSchema.index({refId: 1, unique:true});
	userStudentsAccessSchema.index({userRefId: 1});

	const Student = mongoose.model('Student', studentSchema);
	const UserStudentsAccessModel = mongoose.model('userStudentsAccess', userStudentsAccessSchema);

	const initDbGen = require('students-test-db');
	const initDb = new initDbGen({
		oneToManyAccessModel: UserStudentsAccessModel,
		oneToManyAccessModelName: 'userStudentsAccess',
		model: Student,
		dbName: 'student',
		config: this.config
	});

	this.initCallback();
	return this;
};

//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();

