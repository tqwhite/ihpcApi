'use strict';
const qtoolsGen = require('qtools');
const qtools = new qtoolsGen(module);
//const crypt=require('crypto');
const async = require('async');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {

	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'config',
				optional: false
			},
			{
				name: 'router',
				optional: false
			},
			{
				name: 'mongoose',
				optional: false
			},
			{
				name: 'permissionMaster',
				optional: false
			},
			{
				name: 'initCallback',
				optional: false
			}
		]
	});

	//LOCAL VARIABLES ====================================
	const mongoose = this.mongoose;

	//LOCAL FUNCTIONS ====================================

	//METHODS AND PROPERTIES ====================================

	this.shutdown = (message, callback) => {
		console.log(`shutting down ${__dirname}`);
		callback('', message);
	}

	const getAccessList = (criteria, callback) => {
		StudentPlansAccessModel.find(criteria, callback);

	}

	const getList = (criteria, callback) => {
		Plan.find(criteria, callback)
		.sort([['title', 'ascending']]);

	}

	const putItem = function(id, inData, callback) {
		Plan.update({
			_id: id
		}, inData, {}, callback);
	}

	const postItem = function(inData, callback) {
		var item = new Plan(inData);
		item.save(callback);
	}

	const postAccessItem = function(inData, callback) {
		var item = new StudentPlansAccessModel(inData);
		item.save(callback);
	}

	const deleteItem = function(id, callback) {
		Plan.remove({
			_id: id
		}, callback);
	}

	const newAccessItem=(inData, studentRefId)=>{
		return {
				refId:qtools.newGuid(),
				studentRefId:studentRefId,
				planRefIdList:[inData.refId]
			}
	}

	//API ENDPOINTS ====================================
	let route;
	let method;

	route = new RegExp('/plan/reinitialize/(.*)$');
	method='get';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {
		initDb.initializeDb((err, result) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (plan.reinitialize()) ' + err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});

	});
	
	route = new RegExp('/plan/*?(.*)$');
	method='get';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {
		//	const constraint={userRefId:req.tokenJwtDecoded.userRefId};
		const taskList = [];
		const accessList=[];

		taskList.push((asyncNext) => {
			if (!req.query.studentRefId) {
				asyncNext({
					code: '500',
					errorText: 'No studentRefId specified (plan.get())'
				});
				return;
			}
			getAccessList({studentRefId:req.query.studentRefId}, (err, result) => {
				if (err) {
					asyncNext({
						code: '500',
						errorText: 'Database access problem (plan.get())',
						err: err
					});
				} else {
				if (typeof(result[0])!='undefined'){
					result[0].planRefIdList.map((item)=>{
						accessList.push(item)
					});
					}
					asyncNext();
				}
			});
		});
		
		
		
		taskList.push((asyncNext) => {
			getList({refId: {$in: accessList}}, (err, users) => {
				if (err) {
					asyncNext({
						code: '500',
						errorText: 'Database access problem (plan.get())',
						err: err
					});
				} else {
					res.json({
						token: this.permissionMaster.updateToken(req),
						data: users,
						accessList:accessList
					});
				}
			});
		});

		async.series(taskList, next);

	});

	route = new RegExp('plan/(.*)$');
	method='put';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {

		putItem(req.params[0], req.body, (err, result) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (plan.put())',
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});

	});

	route = new RegExp('plan$');
	method='post';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {

		const taskList=[];
		let accessItem;
		let skipAccessWrite=false;
		taskList.push((asyncNext) => {
			getAccessList({studentRefId:req.body.studentRefId}, (err, result) => {
				if (err) {
					asyncNext({
						code: '500',
						errorText: 'Database access problem (plan.post())',
						err: err
					});
				} else {
				if (typeof(result[0])!='undefined'){

						accessItem=result[0];
						
						if (accessItem.planRefIdList.indexOf(req.body.refId)>-1){
							skipAccessWrite=true;
							next();
							return;
						}
						
						accessItem.planRefIdList.push(req.body.refId);


					}
					else{
						accessItem=newAccessItem(req.body, req.body.studentRefId);
					}
					asyncNext();
				}
			});
		});
		
	
		taskList.push((asyncNext)=>{
			if (skipAccessWrite){
				asyncNext();
				return;
			}
			postAccessItem(accessItem, asyncNext);
		});
		
		taskList.push((asyncNext) => {
			postItem(req.body, (err, result) => {
				if (err) {
					asyncNext({
						code: '500',
						errorText: 'Database access problem (plan.post())',
						err: err
					});
				} else {
console.dir({"result":result});


					res.json({
						token: this.permissionMaster.updateToken(req),
						data: [result]
					});
				}
			});
		});

		async.series(taskList, next);


	});

	route = new RegExp('plan/(.*)$');
	method='delete';
	this.permissionMaster.addRoute(method, route, 'nurse editor admin');
	this.router[method](route, (req, res, next) => {

		deleteItem(req.params[0], (err, result) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (plan.delete())',
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});

	});

	//INITIALIZATION ====================================

	const planSchema = mongoose.Schema({
		debugDataVersion: String,
		refId: String,
		conditions:[{
			refId: String,
			sourceConditionRefId: String,
			title: String,
			diagnoses:[{
				refId: String,
				sourceDiagnosisRefId: String,
				assessmentData: String,
				nursingDiagnosis: String,
				interventions: String,
				outcomes: String,
				shortName: String
			}]
		}]

	},
	{
	  timestamps: true
	});
	
		
	planSchema.index({refId: 1, unique:true});


	const studentPlansAccess = mongoose.Schema({
		refId: String,
		studentRefId: String,
		planRefIdList: [String]
	},
	{
	  timestamps: true
	});
	
	studentPlansAccess.index({refId: 1});
	studentPlansAccess.index({studentRefId: 1});

	const Plan = mongoose.model('Plan', planSchema);
	const StudentPlansAccessModel = mongoose.model('studentPlansAccess', studentPlansAccess);

// 	const initDbGen = require('plans-test-db');
// 	const initDb = new initDbGen({
// 		oneToManyAccessModel: StudentPlansAccessModel,
// 		oneToManyAccessModelName: 'studentPlansAccess',
// 		model: Plan,
// 		dbName: 'plan',
// 		config: this.config
// 	});

	this.initCallback();
	return this;
};

//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();

