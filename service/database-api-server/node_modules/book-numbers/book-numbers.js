'use strict';
const qtoolsGen = require('qtools');
const qtools = new qtoolsGen(module);
//const crypt=require('crypto');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'config',
				optional: false
			},
			{
				name: 'apiManager',
				optional: true
			},
			{
				name: 'router',
				optional: false
			},
			{
				name: 'mongoose',
				optional: false
			},
			{
				name: 'permissionMaster',
				optional: false
			},
			{
				name: 'initCallback',
				optional: false
			}
		]
	});

	//LOCAL VARIABLES ====================================
	const mongoose = this.mongoose;

	//METHODS AND PROPERTIES ====================================

	this.shutdown = (message, callback) => {
		console.log(`shutting down ${__dirname}`);
		callback('', message);
	};

	const recordTransaction = (registerArgs, callback) => {
		const localCallback = (err, result) => {
			if (err) {
				callback(err);
				return;
			}

			if (result.length) {
				callback({
					errmsg: 'Update Subscription Code already used. reloadBase',
					reloadBase:true
				});
				return;
			}

			const transactionIsGood = !result.length;
			if (transactionIsGood) {
				postItem(registerArgs, callback);
				return;
			}

			callback({
				errmsg: 'Something unknowable happened in booknumbers'
			});
		};

		getOne(registerArgs.number, localCallback);
	};

	const checkBookNumberAvailability = (registerArgs, callback) => {
		const localCallback = (err, result) => {
			if (err) {
				callback(err);
				return;
			}
			if (!result.length) {
				callback({
					errmsg: 'No such book number'
				});
				return;
			}
			if (result[0].userRefId) {
				callback({
					errmsg: 'Book number already used'
				});
				return;
			}

			callback('', result[0]._id);
		};

		getOne(registerArgs.bookNumber, localCallback);
	};

	const updateBookNumber = (_id, userRefId, callback) => {
		putItem(_id, { userRefId: userRefId }, callback);
	};

	//LOCAL FUNCTIONS ====================================

	const getOne = (number, callback) => {
		BookNumber.find({ number: number.toUpperCase() }, callback);
	};

	const getList = (criteria, callback) => {
		BookNumber.find(criteria, callback);
	};

	const putItem = function(id, inData, callback) {
		BookNumber.update(
			{
				_id: id
			},
			inData,
			{},
			callback
		);
	};

	const postItem = function(inData, callback) {
		inData.number = inData.number.toUpperCase();
		var item = new BookNumber(inData);
		item.save(callback);
	};

	const deleteItem = function(id, callback) {
		BookNumber.remove(
			{
				_id: id
			},
			callback
		);
	};

	//API ENDPOINTS ====================================
	let route;
	let method;

	route = new RegExp('/bookNumber/reinitialize/(.*)$');
	method = 'get';
	this.permissionMaster.addRoute(method, route, 'all');
	this.router[method](route, (req, res, next) => {
		initDb.initializeDb((err, result) => {
			if (err) {
				next({
					code: '500',
					errorText: 'Database access problem (bookNumber.reinitialize()) ' +
						err,
					err: err
				});
			} else {
				res.json({
					token: this.permissionMaster.updateToken(req),
					data: result
				});
			}
		});
	});

	//INITIALIZATION ====================================

	this.apiManager.registerApi(
		'checkBookNumberAvailability',
		checkBookNumberAvailability
	);
	this.apiManager.registerApi('recordTransaction', recordTransaction);

	this.apiManager.registerApi('updateBookNumber', updateBookNumber);

	/*
		Note: Recently I have realized that the real meaning of a nook number is access to
		the application. A book number is a token that grants a year's access.
		
		This realization comes as I need to find a way to let others create access to the
		application to continue a subscription beyond the original period. I have decided
		that stores can create and sell 'book numbers' and assign them some period of
		access. For this use case, I am calling book numbers 'transaction IDs'.
		
		This has two consequences. One is that the rules for validity when used change,
		sort of. At the start, the presence of a userRefId in the book number record
		signalled that it was used. This is still the case for transaction Ids. However,
		this is detected by virtue of the fact that the transaction ID (booknumbers.number)
		is not in the database at all. This means that I have to have two access methods
		(it's different examining the userRefId of a null object) and that is a little 
		hinky but, not too bad.
		
		The other is that the name of the database collection booknumber is no longer 
		correct. It should be called something more like subscriptionInventoryRecords.
		However, renaming it is way, way too much trouble. Consequently, this is a 
		compromise that has to be accepted.
	*/
	
	//db.booknumbers.find({updatedAt:{$exists:true}})
	
	const bookNumberSchema = mongoose.Schema(
		{
			debugDataVersion: String,
			refId: String,
			number: String,
			role: String,
			sequence: Number,
			category: String,
			months: Number,
			userRefId: String,
			summaryString:String
		},
		{
			timestamps: true
		}
	);

	bookNumberSchema.index({ refId: 1, unique: true });
	bookNumberSchema.index({ userRefId: 1 });
	bookNumberSchema.index({ number: 1 });

	const BookNumber = mongoose.model('BookNumber', bookNumberSchema);

// 	const initDbGen = require('book-numbers-test-db');
// 	const initDb = new initDbGen({
// 		model: BookNumber,
// 		dbName: 'bookNumber',
// 		config: this.config
// 	});

	this.initCallback();
	return this;
};

//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();
